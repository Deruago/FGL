#ifndef FGL_IR_GENERATE_CPP_ENTRYEXITLISTENERTEMPLATE_h
#define FGL_IR_GENERATE_CPP_ENTRYEXITLISTENERTEMPLATE_h

#include <string>
#include <variant>
#include <vector>

namespace fgl::ir::generate::cpp
{
	/*!	\class EntryExitListenerTemplate
	 *
	 *	\brief Generates code for "EntryExitListenerTemplate"
	 *
	 *	\details This is generated by DST.
	 *	For more information visit: https://github.com/Deruago/DeamerStringTemplate
	 */
	class EntryExitListenerTemplate
	{
	public:
		enum class Type
		{
			Unknown,
			Scope,

			// User defined types
			accept_function_name_,
			action_id_,
			action_pop_,
			action_push_,
			base_dispatch_function_,
			class_name_,
			class_namespace_,
			const_qualifier_,
			constexpr_,
			dispatch_function_,
			dispatch_mechanic_,
			enter_function_name_,
			enter_function_name_fgl_,
			enter_function_name_legacy_ast_,
			enter_function_name_ls_,
			entry_cases_,
			entry_conditional_,
			entry_manipulation_,
			entry_node_,
			entry_object_type_,
			exit_cases_,
			exit_function_name_,
			exit_function_name_fgl_,
			exit_function_name_legacy_ast_,
			exit_function_name_ls_,
			exit_node_,
			exit_object_type_,
			file_,
			flavor_,
			flavor_action_stack_,
			flavor_count_type_,
			flavor_declaration_,
			flavor_enum_to_type_conversion_,
			flavor_enum_to_type_conversion_case_,
			flavor_forward_declaration_,
			flavor_invalidation_type_,
			flavor_name_,
			flavor_specialization_,
			flavor_specialization_case_,
			flavor_specialization_forward_declaration_,
			flavor_specialization_member_,
			flavor_specialization_name_,
			flavor_specialization_type_,
			flavor_specialization_type_conversion_,
			flavor_specialization_type_definition_,
			flavor_specialization_type_definition_case_,
			flavor_type_definition_,
			flavor_type_definition_default_case_,
			flavor_type_definition_specialization_case_,
			flavor_type_name_,
			flavor_value_,
			flavoring_name_,
			function_optional_template_argument_,
			function_template_argument_,
			function_template_argument_typename_,
			function_type_,
			function_type_ls_,
			header_guard_,
			inherit_,
			invalidation_add_,
			invalidation_counter_,
			invalidation_remove_,
			is_invalidated_check_,
			language_name_,
			left_angle_bracket_,
			left_bracket_,
			left_curly_bracket_,
			miror_manipulation_,
			object_base_type_,
			object_type_,
			object_type_name_,
			optional_action_pop_,
			optional_action_push_,
			optional_dispatch_mechanic_,
			optional_flavor_action_stack_,
			optional_invalidation_add_,
			optional_invalidation_counter_,
			optional_invalidation_remove_,
			optional_is_invalidated_check_,
			optional_value_,
			output_name_,
			right_angle_bracket_,
			right_bracket_,
			right_curly_bracket_,
			sub_member_access_name_,
			target_namespace_,
			template_base_dispatch_function_,
			user_function_section_,
			user_include_section_,
			user_member_section_,
			value_,
			visit_function_name_,

		};

		enum class ScopeType
		{
			Unknown,

			// Default
			Default_,
			Upper_,
			Lower_,

			Snake_,
			Slash_,
			BackSlash_,
			Colon_,
			DoubleColon_,

			Variable_Field_,
			Variable_Field_Separator_,
			Function_Field_,
			Function_Field_Separator_,

		};

		static constexpr const char* ConvertEnumToName(
			::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type enumerationValue)
		{
			switch (enumerationValue)
			{
			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::accept_function_name_: {
				return "accept_function_name";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::action_id_: {
				return "action_id";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::action_pop_: {
				return "action_pop";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::action_push_: {
				return "action_push";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				base_dispatch_function_: {
				return "base_dispatch_function";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::class_name_: {
				return "class_name";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::class_namespace_: {
				return "class_namespace";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::const_qualifier_: {
				return "const_qualifier";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::constexpr_: {
				return "constexpr";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::dispatch_function_: {
				return "dispatch_function";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::dispatch_mechanic_: {
				return "dispatch_mechanic";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::enter_function_name_: {
				return "enter_function_name";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				enter_function_name_fgl_: {
				return "enter_function_name_fgl";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				enter_function_name_legacy_ast_: {
				return "enter_function_name_legacy_ast";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				enter_function_name_ls_: {
				return "enter_function_name_ls";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::entry_cases_: {
				return "entry_cases";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::entry_conditional_: {
				return "entry_conditional";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::entry_manipulation_: {
				return "entry_manipulation";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::entry_node_: {
				return "entry_node";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::entry_object_type_: {
				return "entry_object_type";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::exit_cases_: {
				return "exit_cases";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::exit_function_name_: {
				return "exit_function_name";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				exit_function_name_fgl_: {
				return "exit_function_name_fgl";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				exit_function_name_legacy_ast_: {
				return "exit_function_name_legacy_ast";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				exit_function_name_ls_: {
				return "exit_function_name_ls";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::exit_node_: {
				return "exit_node";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::exit_object_type_: {
				return "exit_object_type";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::file_: {
				return "file";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_: {
				return "flavor";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_action_stack_: {
				return "flavor_action_stack";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_count_type_: {
				return "flavor_count_type";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_declaration_: {
				return "flavor_declaration";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_enum_to_type_conversion_: {
				return "flavor_enum_to_type_conversion";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_enum_to_type_conversion_case_: {
				return "flavor_enum_to_type_conversion_case";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_forward_declaration_: {
				return "flavor_forward_declaration";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_invalidation_type_: {
				return "flavor_invalidation_type";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_name_: {
				return "flavor_name";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_specialization_: {
				return "flavor_specialization";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_specialization_case_: {
				return "flavor_specialization_case";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_specialization_forward_declaration_: {
				return "flavor_specialization_forward_declaration";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_specialization_member_: {
				return "flavor_specialization_member";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_specialization_name_: {
				return "flavor_specialization_name";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_specialization_type_: {
				return "flavor_specialization_type";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_specialization_type_conversion_: {
				return "flavor_specialization_type_conversion";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_specialization_type_definition_: {
				return "flavor_specialization_type_definition";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_specialization_type_definition_case_: {
				return "flavor_specialization_type_definition_case";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_type_definition_: {
				return "flavor_type_definition";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_type_definition_default_case_: {
				return "flavor_type_definition_default_case";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				flavor_type_definition_specialization_case_: {
				return "flavor_type_definition_specialization_case";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_type_name_: {
				return "flavor_type_name";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_value_: {
				return "flavor_value";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavoring_name_: {
				return "flavoring_name";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				function_optional_template_argument_: {
				return "function_optional_template_argument";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				function_template_argument_: {
				return "function_template_argument";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				function_template_argument_typename_: {
				return "function_template_argument_typename";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::function_type_: {
				return "function_type";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::function_type_ls_: {
				return "function_type_ls";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::header_guard_: {
				return "header_guard";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::inherit_: {
				return "inherit";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::invalidation_add_: {
				return "invalidation_add";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::invalidation_counter_: {
				return "invalidation_counter";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::invalidation_remove_: {
				return "invalidation_remove";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::is_invalidated_check_: {
				return "is_invalidated_check";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::language_name_: {
				return "language_name";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::left_angle_bracket_: {
				return "left_angle_bracket";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::left_bracket_: {
				return "left_bracket";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::left_curly_bracket_: {
				return "left_curly_bracket";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::miror_manipulation_: {
				return "miror_manipulation";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::object_base_type_: {
				return "object_base_type";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::object_type_: {
				return "object_type";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::object_type_name_: {
				return "object_type_name";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::optional_action_pop_: {
				return "optional_action_pop";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::optional_action_push_: {
				return "optional_action_push";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				optional_dispatch_mechanic_: {
				return "optional_dispatch_mechanic";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				optional_flavor_action_stack_: {
				return "optional_flavor_action_stack";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				optional_invalidation_add_: {
				return "optional_invalidation_add";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				optional_invalidation_counter_: {
				return "optional_invalidation_counter";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				optional_invalidation_remove_: {
				return "optional_invalidation_remove";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				optional_is_invalidated_check_: {
				return "optional_is_invalidated_check";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::optional_value_: {
				return "optional_value";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::output_name_: {
				return "output_name";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::right_angle_bracket_: {
				return "right_angle_bracket";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::right_bracket_: {
				return "right_bracket";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::right_curly_bracket_: {
				return "right_curly_bracket";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				sub_member_access_name_: {
				return "sub_member_access_name";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::target_namespace_: {
				return "target_namespace";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				template_base_dispatch_function_: {
				return "template_base_dispatch_function";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
				user_function_section_: {
				return "user_function_section";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::user_include_section_: {
				return "user_include_section";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::user_member_section_: {
				return "user_member_section";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::value_: {
				return "value";
			}

			case ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::visit_function_name_: {
				return "visit_function_name";
			}
			}

			return "";
		}

	public:
		struct VariableBase
		{
			// The value is either a string
			// or a vector of variables.
			std::variant<std::string, std::vector<VariableBase*>> value;
			bool isString = true;

			::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type type =
				::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::Unknown;

			VariableBase() : VariableBase(std::vector<VariableBase*>())
			{
			}

			virtual ~VariableBase() = default;

			VariableBase(const char* text)
			{
				isString = true;
				value = text;
			}

			VariableBase(const std::string& text)
			{
				isString = true;
				value = text;
			}

			VariableBase(std::vector<VariableBase*> variables)
			{
				isString = false;
				value = variables;
			}

			VariableBase* This()
			{
				return this;
			}

			virtual std::string GetValue()
			{
				if (isString)
				{
					return std::get<std::string>(value);
				}
				else
				{
					std::string output;
					auto& variables = std::get<std::vector<VariableBase*>>(value);
					for (auto* variable : variables)
					{
						output += variable->GetValue();
					}
					return output;
				}
			}

			std::string GetName()
			{
				return ConvertEnumToName(type);
			}

			VariableBase& operator=(const std::string& variable)
			{
				return Set(variable);
			}

			VariableBase& operator=(VariableBase* variable)
			{
				return Set(variable);
			}

			VariableBase& operator+=(VariableBase* variable)
			{
				return Add(variable);
			}

			VariableBase& operator+=(const std::string& variable)
			{
				return Add(variable);
			}

			VariableBase& Set(const std::string& variable)
			{
				value = variable;
				isString = true;

				return *this;
			}

			VariableBase& Set(VariableBase* variable)
			{
				if (variable == this)
				{
					return *this;
				}

				value = variable->value;
				isString = variable->isString;

				return *this;
			}

			VariableBase& Add(const std::string& variable)
			{
				if (isString)
				{
					auto& text = std::get<std::string>(value);
					text += variable;
					value = text;
				}
				else
				{
					auto& vector = std::get<std::vector<VariableBase*>>(value);
					vector.push_back(new VariableBase(variable));
					value = vector;
				}

				return *this;
			}

			VariableBase& Add(VariableBase* variable)
			{
				if (variable == this)
				{
					return *this;
				}

				if (isString)
				{
					// convert current -> variablebase
					// then create a vector.
					auto& currentValue = std::get<std::string>(value);
					auto* currentValueAsVariableBase = new VariableBase(currentValue);
					value = std::vector<VariableBase*>({currentValueAsVariableBase, variable});

					isString = false;
				}
				else
				{
					auto& vector = std::get<std::vector<VariableBase*>>(value);
					vector.push_back(variable);
					value = vector;
				}

				return *this;
			}

			void Clear()
			{
				if (isString)
				{
					value = "";
				}
				else
				{
					value = std::vector<VariableBase*>();
				}
			}

			void* operator new(size_t size)
			{
				void* newVariable = ::operator new(size);
				variables_to_delete.emplace_back(static_cast<VariableBase*>(newVariable));

				return newVariable;
			}
		};

		static VariableBase* GenerateVariable(VariableBase* variable)
		{
			return variable;
		}

		static VariableBase* GenerateVariable(const std::string& variable)
		{
			return new VariableBase(variable);
		}

		struct VariableScope : public VariableBase
		{
			::fgl::ir::generate::cpp::EntryExitListenerTemplate::ScopeType scope_type =
				::fgl::ir::generate::cpp::EntryExitListenerTemplate::ScopeType::Unknown;
			bool isReserved = false;

			VariableScope(
				::fgl::ir::generate::cpp::EntryExitListenerTemplate::ScopeType scope_type_,
				bool isReserved_ = false)
				: VariableBase(),
				  scope_type(scope_type_),
				  isReserved(isReserved_)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::Scope;
			}

			VariableScope(
				const char* text,
				::fgl::ir::generate::cpp::EntryExitListenerTemplate::ScopeType scope_type_,
				bool isReserved_ = false)
				: VariableBase(text),
				  scope_type(scope_type_),
				  isReserved(isReserved_)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::Scope;
			}

			VariableScope(
				std::vector<VariableBase*> variable,
				::fgl::ir::generate::cpp::EntryExitListenerTemplate::ScopeType scope_type_,
				bool isReserved_ = false)
				: VariableBase(variable),
				  scope_type(scope_type_),
				  isReserved(isReserved_)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::Scope;
			}
		};

		struct Variable_ReservedScope_Upper : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Upper(VariableBase* base_)
				: VariableScope(
					  ::fgl::ir::generate::cpp::EntryExitListenerTemplate::ScopeType::Upper_, true),
				  base(base_)
			{
			}

			virtual std::string GetValue() override
			{
				std::string upperVariant;
				std::string currentValue = base->GetValue();

				for (const auto character : currentValue)
				{
					upperVariant += std::toupper(character);
				}

				return upperVariant;
			}
		};

		struct Variable_ReservedScope_Lower : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Lower(VariableBase* base_)
				: VariableScope(
					  ::fgl::ir::generate::cpp::EntryExitListenerTemplate::ScopeType::Lower_, true),
				  base(base_)
			{
			}

			virtual std::string GetValue() override
			{
				std::string lowerVariant;
				std::string currentValue = base->GetValue();

				for (const auto character : currentValue)
				{
					lowerVariant += std::tolower(character);
				}

				return lowerVariant;
			}
		};

		struct Variable_ReservedScope_Snake : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Snake(VariableBase* base_)
				: VariableScope(
					  ::fgl::ir::generate::cpp::EntryExitListenerTemplate::ScopeType::Snake_, true),
				  base(base_)
			{
			}

			virtual std::string GetValue() override
			{
				std::string snakeVariant;
				std::string currentValue = base->GetValue();

				bool lastWasNonAlpha = true;
				for (const auto character : currentValue)
				{
					if (std::isalpha(character))
					{
						snakeVariant += character;
						lastWasNonAlpha = false;
					}
					else
					{
						if (lastWasNonAlpha)
						{
							continue;
						}

						snakeVariant += '_';
						lastWasNonAlpha = true;
					}
				}

				// If it contains text
				// remove the tail
				if (!snakeVariant.empty() && lastWasNonAlpha)
				{
					snakeVariant.pop_back();
				}

				return snakeVariant;
			}
		};

		struct Variable_ReservedScope_Slash : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Slash(VariableBase* base_)
				: VariableScope(
					  ::fgl::ir::generate::cpp::EntryExitListenerTemplate::ScopeType::Slash_, true),
				  base(base_)
			{
			}

			virtual std::string GetValue() override
			{
				std::string slashVariant;
				std::string currentValue = base->GetValue();

				bool lastWasNonAlpha = true;
				for (const auto character : currentValue)
				{
					if (std::isalpha(character))
					{
						slashVariant += character;
						lastWasNonAlpha = false;
					}
					else
					{
						if (lastWasNonAlpha)
						{
							continue;
						}

						slashVariant += '/';
						lastWasNonAlpha = true;
					}
				}

				// If it contains text
				// remove the tail
				if (!slashVariant.empty() && lastWasNonAlpha)
				{
					slashVariant.pop_back();
				}

				return slashVariant;
			}
		};

		struct Variable_ReservedScope_DoubleColon : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_DoubleColon(VariableBase* base_)
				: VariableScope(
					  ::fgl::ir::generate::cpp::EntryExitListenerTemplate::ScopeType::DoubleColon_,
					  true),
				  base(base_)
			{
			}

			virtual std::string GetValue() override
			{
				std::string doubleColonVariant;
				std::string currentValue = base->GetValue();

				bool lastWasNonAlpha = true;
				for (const auto character : currentValue)
				{
					if (std::isalpha(character))
					{
						doubleColonVariant += character;
						lastWasNonAlpha = false;
					}
					else
					{
						if (lastWasNonAlpha)
						{
							continue;
						}

						doubleColonVariant += "::";
						lastWasNonAlpha = true;
					}
				}

				// If it contains text
				// remove the tail
				if (!doubleColonVariant.empty() && lastWasNonAlpha)
				{
					doubleColonVariant.pop_back();
					doubleColonVariant.pop_back();
				}

				return doubleColonVariant;
			}
		};

		struct VariableScopes : public VariableBase
		{
			// Default scopes
			VariableBase* default_ = new VariableScope(
				::fgl::ir::generate::cpp::EntryExitListenerTemplate::ScopeType::Default_, true);
			VariableBase* upper_ = new Variable_ReservedScope_Upper(this);
			VariableBase* lower_ = new Variable_ReservedScope_Lower(this);

			VariableBase* snake_ = new Variable_ReservedScope_Snake(this);
			VariableBase* slash_ = new Variable_ReservedScope_Slash(this);
			VariableBase* double_colon_ = new Variable_ReservedScope_DoubleColon(this);

			VariableBase* variable_field_ = new VariableScope(
				::fgl::ir::generate::cpp::EntryExitListenerTemplate::ScopeType::Variable_Field_,
				true);
			VariableBase* variable_field_separator_ =
				new VariableScope("\n",
								  ::fgl::ir::generate::cpp::EntryExitListenerTemplate::ScopeType::
									  Variable_Field_Separator_,
								  true);

			// Ctor
			VariableScopes() : VariableBase()
			{
			}

			VariableScopes(const char* text) : VariableBase(text)
			{
			}

			VariableScopes(const std::string& text) : VariableBase(text)
			{
			}

			VariableScopes(std::vector<VariableBase*> variables) : VariableBase(variables)
			{
			}

			// Dtor
			virtual ~VariableScopes() override = default;

			// Calls
			VariableBase* Default()
			{
				return default_;
			}
			VariableBase* Upper()
			{
				return upper_;
			}

			VariableBase* Lower()
			{
				return lower_;
			}

			VariableBase* Underscore()
			{
				return snake_;
			}

			VariableBase* Snake()
			{
				return snake_;
			}

			VariableBase* Slash()
			{
				return slash_;
			}

			VariableBase* DoubleColon()
			{
				return double_colon_;
			}

			VariableBase* Variable_Field()
			{
				return variable_field_;
			}

			VariableBase* Variable_Field_Separator()
			{
				return variable_field_separator_;
			}

			void ExpandVariableField()
			{
				// currentvalue + separator
				const auto currentValue = GetValue() + Variable_Field_Separator()->GetValue();
				*Variable_Field() += currentValue;
			}
		};

	public:
		struct Variable_accept_function_name_ : public VariableScopes
		{
			static constexpr auto name = "accept_function_name_";

			Variable_accept_function_name_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					accept_function_name_;
			}

			virtual ~Variable_accept_function_name_() override = default;

			Variable_accept_function_name_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					accept_function_name_;
			}

			Variable_accept_function_name_&
			operator=(const Variable_accept_function_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_action_id_ : public VariableScopes
		{
			static constexpr auto name = "action_id_";

			Variable_action_id_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::action_id_;
			}

			virtual ~Variable_action_id_() override = default;

			Variable_action_id_(EntryExitListenerTemplate* entryexitlistenertemplate_,
								const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::action_id_;
			}

			Variable_action_id_& operator=(const Variable_action_id_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_action_pop_ : public VariableScopes
		{
			static constexpr auto name = "action_pop_";

			Variable_action_pop_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::action_pop_;
			}

			virtual ~Variable_action_pop_() override = default;

			Variable_action_pop_(EntryExitListenerTemplate* entryexitlistenertemplate_,
								 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::action_pop_;
			}

			Variable_action_pop_& operator=(const Variable_action_pop_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_action_push_ : public VariableScopes
		{
			static constexpr auto name = "action_push_";

			Variable_action_push_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::action_push_;
			}

			virtual ~Variable_action_push_() override = default;

			Variable_action_push_(EntryExitListenerTemplate* entryexitlistenertemplate_,
								  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::action_push_;
			}

			Variable_action_push_& operator=(const Variable_action_push_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_base_dispatch_function_ : public VariableScopes
		{
			static constexpr auto name = "base_dispatch_function_";

			Variable_base_dispatch_function_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					base_dispatch_function_;
			}

			virtual ~Variable_base_dispatch_function_() override = default;

			Variable_base_dispatch_function_(EntryExitListenerTemplate* entryexitlistenertemplate_,
											 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					base_dispatch_function_;
			}

			Variable_base_dispatch_function_&
			operator=(const Variable_base_dispatch_function_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_class_name_ : public VariableScopes
		{
			static constexpr auto name = "class_name_";

			Variable_class_name_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::class_name_;
			}

			virtual ~Variable_class_name_() override = default;

			Variable_class_name_(EntryExitListenerTemplate* entryexitlistenertemplate_,
								 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::class_name_;
			}

			Variable_class_name_& operator=(const Variable_class_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_class_namespace_ : public VariableScopes
		{
			static constexpr auto name = "class_namespace_";

			Variable_class_namespace_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::class_namespace_;
			}

			virtual ~Variable_class_namespace_() override = default;

			Variable_class_namespace_(EntryExitListenerTemplate* entryexitlistenertemplate_,
									  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::class_namespace_;
			}

			Variable_class_namespace_& operator=(const Variable_class_namespace_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_const_qualifier_ : public VariableScopes
		{
			static constexpr auto name = "const_qualifier_";

			Variable_const_qualifier_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::const_qualifier_;
			}

			virtual ~Variable_const_qualifier_() override = default;

			Variable_const_qualifier_(EntryExitListenerTemplate* entryexitlistenertemplate_,
									  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::const_qualifier_;
			}

			Variable_const_qualifier_& operator=(const Variable_const_qualifier_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_constexpr_ : public VariableScopes
		{
			static constexpr auto name = "constexpr_";

			Variable_constexpr_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::constexpr_;
			}

			virtual ~Variable_constexpr_() override = default;

			Variable_constexpr_(EntryExitListenerTemplate* entryexitlistenertemplate_,
								const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::constexpr_;
			}

			Variable_constexpr_& operator=(const Variable_constexpr_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_dispatch_function_ : public VariableScopes
		{
			static constexpr auto name = "dispatch_function_";

			Variable_dispatch_function_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::dispatch_function_;
			}

			virtual ~Variable_dispatch_function_() override = default;

			Variable_dispatch_function_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::dispatch_function_;
			}

			Variable_dispatch_function_& operator=(const Variable_dispatch_function_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_dispatch_mechanic_ : public VariableScopes
		{
			static constexpr auto name = "dispatch_mechanic_";

			Variable_dispatch_mechanic_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::dispatch_mechanic_;
			}

			virtual ~Variable_dispatch_mechanic_() override = default;

			Variable_dispatch_mechanic_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::dispatch_mechanic_;
			}

			Variable_dispatch_mechanic_& operator=(const Variable_dispatch_mechanic_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_enter_function_name_ : public VariableScopes
		{
			static constexpr auto name = "enter_function_name_";

			Variable_enter_function_name_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::enter_function_name_;
			}

			virtual ~Variable_enter_function_name_() override = default;

			Variable_enter_function_name_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::enter_function_name_;
			}

			Variable_enter_function_name_& operator=(const Variable_enter_function_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_enter_function_name_fgl_ : public VariableScopes
		{
			static constexpr auto name = "enter_function_name_fgl_";

			Variable_enter_function_name_fgl_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					enter_function_name_fgl_;
			}

			virtual ~Variable_enter_function_name_fgl_() override = default;

			Variable_enter_function_name_fgl_(EntryExitListenerTemplate* entryexitlistenertemplate_,
											  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					enter_function_name_fgl_;
			}

			Variable_enter_function_name_fgl_&
			operator=(const Variable_enter_function_name_fgl_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_enter_function_name_legacy_ast_ : public VariableScopes
		{
			static constexpr auto name = "enter_function_name_legacy_ast_";

			Variable_enter_function_name_legacy_ast_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					enter_function_name_legacy_ast_;
			}

			virtual ~Variable_enter_function_name_legacy_ast_() override = default;

			Variable_enter_function_name_legacy_ast_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					enter_function_name_legacy_ast_;
			}

			Variable_enter_function_name_legacy_ast_&
			operator=(const Variable_enter_function_name_legacy_ast_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_enter_function_name_ls_ : public VariableScopes
		{
			static constexpr auto name = "enter_function_name_ls_";

			Variable_enter_function_name_ls_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					enter_function_name_ls_;
			}

			virtual ~Variable_enter_function_name_ls_() override = default;

			Variable_enter_function_name_ls_(EntryExitListenerTemplate* entryexitlistenertemplate_,
											 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					enter_function_name_ls_;
			}

			Variable_enter_function_name_ls_&
			operator=(const Variable_enter_function_name_ls_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_entry_cases_ : public VariableScopes
		{
			static constexpr auto name = "entry_cases_";

			Variable_entry_cases_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::entry_cases_;
			}

			virtual ~Variable_entry_cases_() override = default;

			Variable_entry_cases_(EntryExitListenerTemplate* entryexitlistenertemplate_,
								  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::entry_cases_;
			}

			Variable_entry_cases_& operator=(const Variable_entry_cases_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_entry_conditional_ : public VariableScopes
		{
			static constexpr auto name = "entry_conditional_";

			Variable_entry_conditional_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::entry_conditional_;
			}

			virtual ~Variable_entry_conditional_() override = default;

			Variable_entry_conditional_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::entry_conditional_;
			}

			Variable_entry_conditional_& operator=(const Variable_entry_conditional_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_entry_manipulation_ : public VariableScopes
		{
			static constexpr auto name = "entry_manipulation_";

			Variable_entry_manipulation_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::entry_manipulation_;
			}

			virtual ~Variable_entry_manipulation_() override = default;

			Variable_entry_manipulation_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::entry_manipulation_;
			}

			Variable_entry_manipulation_& operator=(const Variable_entry_manipulation_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_entry_node_ : public VariableScopes
		{
			static constexpr auto name = "entry_node_";

			Variable_entry_node_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::entry_node_;
			}

			virtual ~Variable_entry_node_() override = default;

			Variable_entry_node_(EntryExitListenerTemplate* entryexitlistenertemplate_,
								 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::entry_node_;
			}

			Variable_entry_node_& operator=(const Variable_entry_node_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_entry_object_type_ : public VariableScopes
		{
			static constexpr auto name = "entry_object_type_";

			Variable_entry_object_type_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::entry_object_type_;
			}

			virtual ~Variable_entry_object_type_() override = default;

			Variable_entry_object_type_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::entry_object_type_;
			}

			Variable_entry_object_type_& operator=(const Variable_entry_object_type_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_exit_cases_ : public VariableScopes
		{
			static constexpr auto name = "exit_cases_";

			Variable_exit_cases_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::exit_cases_;
			}

			virtual ~Variable_exit_cases_() override = default;

			Variable_exit_cases_(EntryExitListenerTemplate* entryexitlistenertemplate_,
								 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::exit_cases_;
			}

			Variable_exit_cases_& operator=(const Variable_exit_cases_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_exit_function_name_ : public VariableScopes
		{
			static constexpr auto name = "exit_function_name_";

			Variable_exit_function_name_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::exit_function_name_;
			}

			virtual ~Variable_exit_function_name_() override = default;

			Variable_exit_function_name_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::exit_function_name_;
			}

			Variable_exit_function_name_& operator=(const Variable_exit_function_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_exit_function_name_fgl_ : public VariableScopes
		{
			static constexpr auto name = "exit_function_name_fgl_";

			Variable_exit_function_name_fgl_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					exit_function_name_fgl_;
			}

			virtual ~Variable_exit_function_name_fgl_() override = default;

			Variable_exit_function_name_fgl_(EntryExitListenerTemplate* entryexitlistenertemplate_,
											 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					exit_function_name_fgl_;
			}

			Variable_exit_function_name_fgl_&
			operator=(const Variable_exit_function_name_fgl_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_exit_function_name_legacy_ast_ : public VariableScopes
		{
			static constexpr auto name = "exit_function_name_legacy_ast_";

			Variable_exit_function_name_legacy_ast_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					exit_function_name_legacy_ast_;
			}

			virtual ~Variable_exit_function_name_legacy_ast_() override = default;

			Variable_exit_function_name_legacy_ast_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					exit_function_name_legacy_ast_;
			}

			Variable_exit_function_name_legacy_ast_&
			operator=(const Variable_exit_function_name_legacy_ast_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_exit_function_name_ls_ : public VariableScopes
		{
			static constexpr auto name = "exit_function_name_ls_";

			Variable_exit_function_name_ls_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					exit_function_name_ls_;
			}

			virtual ~Variable_exit_function_name_ls_() override = default;

			Variable_exit_function_name_ls_(EntryExitListenerTemplate* entryexitlistenertemplate_,
											const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					exit_function_name_ls_;
			}

			Variable_exit_function_name_ls_&
			operator=(const Variable_exit_function_name_ls_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_exit_node_ : public VariableScopes
		{
			static constexpr auto name = "exit_node_";

			Variable_exit_node_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::exit_node_;
			}

			virtual ~Variable_exit_node_() override = default;

			Variable_exit_node_(EntryExitListenerTemplate* entryexitlistenertemplate_,
								const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::exit_node_;
			}

			Variable_exit_node_& operator=(const Variable_exit_node_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_exit_object_type_ : public VariableScopes
		{
			static constexpr auto name = "exit_object_type_";

			Variable_exit_object_type_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::exit_object_type_;
			}

			virtual ~Variable_exit_object_type_() override = default;

			Variable_exit_object_type_(EntryExitListenerTemplate* entryexitlistenertemplate_,
									   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::exit_object_type_;
			}

			Variable_exit_object_type_& operator=(const Variable_exit_object_type_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_file_ : public VariableScopes
		{
			static constexpr auto name = "file_";

			VariableBase* Content_ = GenerateVariable("");
			VariableBase* Class_postfix_ = GenerateVariable("");
			VariableBase* Extension_ = GenerateVariable("");
			VariableBase* File_name_ = GenerateVariable("");
			VariableBase* Namespace_ = GenerateVariable("");
			VariableBase* Target_language_ = GenerateVariable("");

			Variable_file_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::file_;
			}

			virtual ~Variable_file_() override = default;

			Variable_file_(EntryExitListenerTemplate* entryexitlistenertemplate_,
						   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::file_;
				*static_cast<VariableBase*>(Content_) = VariableBase(std::vector<VariableBase*>(
					{GenerateVariable("#ifndef "),
					 GenerateVariable(entryexitlistenertemplate_->header_guard_->This()),
					 GenerateVariable("\n#define "),
					 GenerateVariable(entryexitlistenertemplate_->header_guard_->This()),
					 GenerateVariable("\n\n/*\tThis is generated by FGL: https://github"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "com/Deruago/FGL\n *\tFor questions visit the link above!\n * \n "
						 "*\tPlease do not edit this file, instead modify the definition that "
						 "generated this!\n *\n *\tYou can use the class by the following: \n *  "
						 "auto flavoring = ::fgl::flavoring::visitor::"),
					 GenerateVariable(entryexitlistenertemplate_->flavoring_name_->This()),
					 GenerateVariable("();\n *\tflavoring"),
					 GenerateVariable("."),
					 GenerateVariable("Dispatch(tree);\n *\n *\tIf some setup is required, please "
									  "use your inserted functions and members (if any),\n "
									  "*\tbefore using the flavoring class"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "\n *\n *\tNote: This file requires C++17 or any later release"),
					 GenerateVariable("."),
					 GenerateVariable("\n */\n\n// User defined includes\n"),
					 GenerateVariable(
						 entryexitlistenertemplate_->user_include_section_->Variable_Field()),
					 GenerateVariable("\n\n// Required STL includes"),
					 GenerateVariable("."),
					 GenerateVariable("\n#include <vector>\n#include <stack>\n#include "
									  "<string>\n\nnamespace fgl "),
					 GenerateVariable("{"),
					 GenerateVariable(" namespace flavoring "),
					 GenerateVariable("{"),
					 GenerateVariable(" namespace visitor "),
					 GenerateVariable("{"),
					 GenerateVariable("\n\n\t/*!\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("struct "),
					 GenerateVariable(entryexitlistenertemplate_->flavor_value_->This()),
					 GenerateVariable("\n\t *\n\t *\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("brief "),
					 GenerateVariable(entryexitlistenertemplate_->flavor_value_->This()),
					 GenerateVariable(
						 " is used in flavors, when the flavor's value is accessed or modified"),
					 GenerateVariable("."),
					 GenerateVariable("\n\t *\n\t *\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("note If the flavor does not have references to its value, "
									  "it will not be available in that flavor"),
					 GenerateVariable("."),
					 GenerateVariable("\n\t */\n\tstruct "),
					 GenerateVariable(entryexitlistenertemplate_->flavor_value_->This()),
					 GenerateVariable("\n\t"),
					 GenerateVariable("{"),
					 GenerateVariable(
						 "\n\t\t::std::vector<::std::vector<::std::string>> value;\n\n\t\t"),
					 GenerateVariable(entryexitlistenertemplate_->flavor_value_->This()),
					 GenerateVariable("()\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tvalue"),
					 GenerateVariable("."),
					 GenerateVariable("emplace_back();\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\t~"),
					 GenerateVariable(entryexitlistenertemplate_->flavor_value_->This()),
					 GenerateVariable("() = default;\n\n\t\t::std::vector<::std::string> "
									  "GetValue() const\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\treturn *(value"),
					 GenerateVariable("."),
					 GenerateVariable("end() - 1);\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable(
						 "\n\n\t\t::std::vector<::std::string> operator()() const\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\treturn "),
					 GenerateVariable(entryexitlistenertemplate_->flavor_value_->This()),
					 GenerateVariable("::GetValue();\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\tvoid Reduce()\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t(value"),
					 GenerateVariable("."),
					 GenerateVariable("end() - 1)->pop_back();\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable(
						 "\n\n\t\tvoid Expand(const ::std::string& expandedValue)\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t(value"),
					 GenerateVariable("."),
					 GenerateVariable("end() - 1)->push_back(expandedValue);\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\tvoid Expand(const ::std::vector<::std::string>& "
									  "expandedValues)\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable(
						 "\n\t\t\tfor (const auto& expandedValue : expandedValues)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t(value"),
					 GenerateVariable("."),
					 GenerateVariable("end() - 1)->push_back(expandedValue);\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\t"),
					 GenerateVariable(entryexitlistenertemplate_->flavor_value_->This()),
					 GenerateVariable("& operator=(const ::std::string& newValue)\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tvalue"),
					 GenerateVariable("."),
					 GenerateVariable("push_back("),
					 GenerateVariable("{"),
					 GenerateVariable("newValue"),
					 GenerateVariable("}"),
					 GenerateVariable(");\n\n\t\t\treturn *this;\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\t"),
					 GenerateVariable(entryexitlistenertemplate_->flavor_value_->This()),
					 GenerateVariable(
						 "& operator=(const ::std::vector<::std::string>& newValues)\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tvalue"),
					 GenerateVariable("."),
					 GenerateVariable("push_back(newValues);\n\n\t\t\treturn *this;\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\tvoid RemoveValue()\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tvalue"),
					 GenerateVariable("."),
					 GenerateVariable("pop_back();\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t"),
					 GenerateVariable("}"),
					 GenerateVariable(";\n\n\t// Global flavor type forward declarations\n\t"),
					 GenerateVariable(
						 entryexitlistenertemplate_->flavor_forward_declaration_->Variable_Field()),
					 GenerateVariable("\n\t\n\t// Compile time known flavor specialization type "
									  "forward declarations\n\t"),
					 GenerateVariable(
						 entryexitlistenertemplate_->flavor_specialization_forward_declaration_
							 ->Variable_Field()),
					 GenerateVariable("\n\n\t// Base flavor enumerations\n\t"),
					 GenerateVariable(entryexitlistenertemplate_->flavor_type_definition_->This()),
					 GenerateVariable("\n\n\t// Specialization flavor enumerations\n\t"),
					 GenerateVariable(
						 entryexitlistenertemplate_->flavor_specialization_type_definition_
							 ->Variable_Field()),
					 GenerateVariable("\n\n\t// Flavor specialization enum to type conversion\n\t"),
					 GenerateVariable(entryexitlistenertemplate_->flavor_enum_to_type_conversion_
										  ->Variable_Field()),
					 GenerateVariable("\n\n\t/*!\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("struct FlavorStackMemory\n\t *\n\t *\t"),
					 GenerateVariable("\\"),
					 GenerateVariable(
						 "brief This is used to keep track of when a flavor is added/deleted"),
					 GenerateVariable("."),
					 GenerateVariable("\n\t *\n\t *\t"),
					 GenerateVariable("\\"),
					 GenerateVariable(
						 "details It contains an invalidation counter and flavortype variable"),
					 GenerateVariable("."),
					 GenerateVariable("\n\t *\tThese 2 are used to keep track of what flavor was "
									  "added, and if it was deleted"),
					 GenerateVariable("."),
					 GenerateVariable("\n\t *\tDeleted flavors are invalidated in the stack"),
					 GenerateVariable("."),
					 GenerateVariable("\n\t *\n\t *\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("note If stack access is not used, this will not be used"),
					 GenerateVariable("."),
					 GenerateVariable("\n\t *\n\t *\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("note If runtime flavor specialization is supported, every "
									  "check becomes more expensive"),
					 GenerateVariable("."),
					 GenerateVariable("\n\t */\n\tstruct FlavorStackMemory\n\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\tpublic:\n\t\tFlavorType flavorType;\n\n\tpublic:\n\t\t"),
					 GenerateVariable(
						 entryexitlistenertemplate_->optional_invalidation_counter_->This()),
					 GenerateVariable("\n\n\tpublic:\n\t\tFlavorStackMemory(FlavorType "
									  "flavorType_) : flavorType(flavorType_)\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\t~FlavorStackMemory() = default;\n\n\tpublic:\n\t\t"),
					 GenerateVariable(
						 entryexitlistenertemplate_->optional_invalidation_add_->This()),
					 GenerateVariable("\n\t\t"),
					 GenerateVariable(
						 entryexitlistenertemplate_->optional_invalidation_remove_->This()),
					 GenerateVariable("\n\n\t\t"),
					 GenerateVariable(
						 entryexitlistenertemplate_->optional_is_invalidated_check_->This()),
					 GenerateVariable("\n\t"),
					 GenerateVariable("}"),
					 GenerateVariable(";\n\n\t"),
					 GenerateVariable(
						 entryexitlistenertemplate_->flavor_specialization_->Variable_Field()),
					 GenerateVariable("\n\n\t"),
					 GenerateVariable(entryexitlistenertemplate_->flavor_->Variable_Field()),
					 GenerateVariable("\n\n\t/*!\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("class "),
					 GenerateVariable(entryexitlistenertemplate_->flavoring_name_->This()),
					 GenerateVariable("\n\t *\n\t *\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("brief Applies flavoring to "),
					 GenerateVariable(entryexitlistenertemplate_->flavoring_name_->This()),
					 GenerateVariable("."),
					 GenerateVariable("\n\t *\n\t *\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("details This flavoring is generated and optimized using a "
									  "flavoring definition and FGL"),
					 GenerateVariable("."),
					 GenerateVariable("\n\t *\t\n\t *\t"),
					 GenerateVariable("\\"),
					 GenerateVariable(
						 "note It is not recommended to edit this file to apply changes"),
					 GenerateVariable("."),
					 GenerateVariable("\n\t *\tTo apply changes please change the flavoring "
									  "definition of this file"),
					 GenerateVariable("."),
					 GenerateVariable("\n\t *\n\t */\n\tclass "),
					 GenerateVariable(entryexitlistenertemplate_->flavoring_name_->This()),
					 GenerateVariable(" "),
					 GenerateVariable(entryexitlistenertemplate_->inherit_->Variable_Field()),
					 GenerateVariable("\n\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\tprivate:\n\t\t"),
					 GenerateVariable(
						 entryexitlistenertemplate_->flavor_declaration_->Variable_Field()),
					 GenerateVariable("\n\n\tprivate:\n\t\t"),
					 GenerateVariable(
						 entryexitlistenertemplate_->optional_flavor_action_stack_->This()),
					 GenerateVariable("\n\n\tpublic:\n\t\t"),
					 GenerateVariable(entryexitlistenertemplate_->flavoring_name_->This()),
					 GenerateVariable("() = default;\n\t\t~"),
					 GenerateVariable(entryexitlistenertemplate_->flavoring_name_->This()),
					 GenerateVariable("() = default;\n\n\tprivate:\n\t\t// Entry of nodes\n\t\t"),
					 GenerateVariable(entryexitlistenertemplate_->entry_node_->Variable_Field()),
					 GenerateVariable("\n\n\t\t// Exit of nodes\n\t\t"),
					 GenerateVariable(entryexitlistenertemplate_->exit_node_->Variable_Field()),
					 GenerateVariable("\n\t\n"),
					 GenerateVariable(
						 entryexitlistenertemplate_->optional_dispatch_mechanic_->This()),
					 GenerateVariable("\n\n\t// User defined members\n\tpublic:\n\t\t"),
					 GenerateVariable(
						 entryexitlistenertemplate_->user_member_section_->Variable_Field()),
					 GenerateVariable("\n\t\t\n\t// User defined functions\n\tpublic:\n\t\t"),
					 GenerateVariable(
						 entryexitlistenertemplate_->user_function_section_->Variable_Field()),
					 GenerateVariable("\n\n\t"),
					 GenerateVariable("}"),
					 GenerateVariable(";\n\n"),
					 GenerateVariable("}}"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n#endif // "),
					 GenerateVariable(entryexitlistenertemplate_->header_guard_->This()),
					 GenerateVariable("\n")}));
				Content_->type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::Scope;

				*static_cast<VariableBase*>(Class_postfix_) =
					VariableBase(std::vector<VariableBase*>({}));
				Class_postfix_->type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::Scope;

				*static_cast<VariableBase*>(Extension_) =
					VariableBase(std::vector<VariableBase*>({GenerateVariable("h")}));
				Extension_->type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::Scope;

				*static_cast<VariableBase*>(File_name_) = VariableBase(
					std::vector<VariableBase*>({GenerateVariable("EntryExitListener")}));
				File_name_->type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::Scope;

				*static_cast<VariableBase*>(Namespace_) = VariableBase(
					std::vector<VariableBase*>({GenerateVariable("fgl::ir::generate::cpp")}));
				Namespace_->type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::Scope;

				*static_cast<VariableBase*>(Target_language_) =
					VariableBase(std::vector<VariableBase*>({GenerateVariable("C++")}));
				Target_language_->type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::Scope;
			}

			VariableBase* Content() const
			{
				return Content_;
			}

			VariableBase* Class_postfix() const
			{
				return Class_postfix_;
			}

			VariableBase* Extension() const
			{
				return Extension_;
			}

			VariableBase* File_name() const
			{
				return File_name_;
			}

			VariableBase* Namespace() const
			{
				return Namespace_;
			}

			VariableBase* Target_language() const
			{
				return Target_language_;
			}

			Variable_file_& operator=(const Variable_file_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				*Content_ = *variable.Content_;
				*Class_postfix_ = *variable.Class_postfix_;
				*Extension_ = *variable.Extension_;
				*File_name_ = *variable.File_name_;
				*Namespace_ = *variable.Namespace_;
				*Target_language_ = *variable.Target_language_;

				return *this;
			}
		};

		struct Variable_flavor_ : public VariableScopes
		{
			static constexpr auto name = "flavor_";

			Variable_flavor_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_;
			}

			virtual ~Variable_flavor_() override = default;

			Variable_flavor_(EntryExitListenerTemplate* entryexitlistenertemplate_,
							 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_;
			}

			Variable_flavor_& operator=(const Variable_flavor_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_action_stack_ : public VariableScopes
		{
			static constexpr auto name = "flavor_action_stack_";

			Variable_flavor_action_stack_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_action_stack_;
			}

			virtual ~Variable_flavor_action_stack_() override = default;

			Variable_flavor_action_stack_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_action_stack_;
			}

			Variable_flavor_action_stack_& operator=(const Variable_flavor_action_stack_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_count_type_ : public VariableScopes
		{
			static constexpr auto name = "flavor_count_type_";

			Variable_flavor_count_type_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_count_type_;
			}

			virtual ~Variable_flavor_count_type_() override = default;

			Variable_flavor_count_type_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_count_type_;
			}

			Variable_flavor_count_type_& operator=(const Variable_flavor_count_type_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_declaration_ : public VariableScopes
		{
			static constexpr auto name = "flavor_declaration_";

			Variable_flavor_declaration_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_declaration_;
			}

			virtual ~Variable_flavor_declaration_() override = default;

			Variable_flavor_declaration_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_declaration_;
			}

			Variable_flavor_declaration_& operator=(const Variable_flavor_declaration_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_enum_to_type_conversion_ : public VariableScopes
		{
			static constexpr auto name = "flavor_enum_to_type_conversion_";

			Variable_flavor_enum_to_type_conversion_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_enum_to_type_conversion_;
			}

			virtual ~Variable_flavor_enum_to_type_conversion_() override = default;

			Variable_flavor_enum_to_type_conversion_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_enum_to_type_conversion_;
			}

			Variable_flavor_enum_to_type_conversion_&
			operator=(const Variable_flavor_enum_to_type_conversion_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_enum_to_type_conversion_case_ : public VariableScopes
		{
			static constexpr auto name = "flavor_enum_to_type_conversion_case_";

			Variable_flavor_enum_to_type_conversion_case_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_enum_to_type_conversion_case_;
			}

			virtual ~Variable_flavor_enum_to_type_conversion_case_() override = default;

			Variable_flavor_enum_to_type_conversion_case_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_enum_to_type_conversion_case_;
			}

			Variable_flavor_enum_to_type_conversion_case_&
			operator=(const Variable_flavor_enum_to_type_conversion_case_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_forward_declaration_ : public VariableScopes
		{
			static constexpr auto name = "flavor_forward_declaration_";

			Variable_flavor_forward_declaration_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_forward_declaration_;
			}

			virtual ~Variable_flavor_forward_declaration_() override = default;

			Variable_flavor_forward_declaration_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_forward_declaration_;
			}

			Variable_flavor_forward_declaration_&
			operator=(const Variable_flavor_forward_declaration_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_invalidation_type_ : public VariableScopes
		{
			static constexpr auto name = "flavor_invalidation_type_";

			Variable_flavor_invalidation_type_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_invalidation_type_;
			}

			virtual ~Variable_flavor_invalidation_type_() override = default;

			Variable_flavor_invalidation_type_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_invalidation_type_;
			}

			Variable_flavor_invalidation_type_&
			operator=(const Variable_flavor_invalidation_type_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_name_ : public VariableScopes
		{
			static constexpr auto name = "flavor_name_";

			Variable_flavor_name_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_name_;
			}

			virtual ~Variable_flavor_name_() override = default;

			Variable_flavor_name_(EntryExitListenerTemplate* entryexitlistenertemplate_,
								  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_name_;
			}

			Variable_flavor_name_& operator=(const Variable_flavor_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_specialization_ : public VariableScopes
		{
			static constexpr auto name = "flavor_specialization_";

			Variable_flavor_specialization_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_;
			}

			virtual ~Variable_flavor_specialization_() override = default;

			Variable_flavor_specialization_(EntryExitListenerTemplate* entryexitlistenertemplate_,
											const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_;
			}

			Variable_flavor_specialization_&
			operator=(const Variable_flavor_specialization_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_specialization_case_ : public VariableScopes
		{
			static constexpr auto name = "flavor_specialization_case_";

			Variable_flavor_specialization_case_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_case_;
			}

			virtual ~Variable_flavor_specialization_case_() override = default;

			Variable_flavor_specialization_case_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_case_;
			}

			Variable_flavor_specialization_case_&
			operator=(const Variable_flavor_specialization_case_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_specialization_forward_declaration_ : public VariableScopes
		{
			static constexpr auto name = "flavor_specialization_forward_declaration_";

			Variable_flavor_specialization_forward_declaration_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_forward_declaration_;
			}

			virtual ~Variable_flavor_specialization_forward_declaration_() override = default;

			Variable_flavor_specialization_forward_declaration_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_forward_declaration_;
			}

			Variable_flavor_specialization_forward_declaration_&
			operator=(const Variable_flavor_specialization_forward_declaration_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_specialization_member_ : public VariableScopes
		{
			static constexpr auto name = "flavor_specialization_member_";

			Variable_flavor_specialization_member_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_member_;
			}

			virtual ~Variable_flavor_specialization_member_() override = default;

			Variable_flavor_specialization_member_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_member_;
			}

			Variable_flavor_specialization_member_&
			operator=(const Variable_flavor_specialization_member_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_specialization_name_ : public VariableScopes
		{
			static constexpr auto name = "flavor_specialization_name_";

			Variable_flavor_specialization_name_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_name_;
			}

			virtual ~Variable_flavor_specialization_name_() override = default;

			Variable_flavor_specialization_name_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_name_;
			}

			Variable_flavor_specialization_name_&
			operator=(const Variable_flavor_specialization_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_specialization_type_ : public VariableScopes
		{
			static constexpr auto name = "flavor_specialization_type_";

			Variable_flavor_specialization_type_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_type_;
			}

			virtual ~Variable_flavor_specialization_type_() override = default;

			Variable_flavor_specialization_type_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_type_;
			}

			Variable_flavor_specialization_type_&
			operator=(const Variable_flavor_specialization_type_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_specialization_type_conversion_ : public VariableScopes
		{
			static constexpr auto name = "flavor_specialization_type_conversion_";

			Variable_flavor_specialization_type_conversion_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_type_conversion_;
			}

			virtual ~Variable_flavor_specialization_type_conversion_() override = default;

			Variable_flavor_specialization_type_conversion_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_type_conversion_;
			}

			Variable_flavor_specialization_type_conversion_&
			operator=(const Variable_flavor_specialization_type_conversion_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_specialization_type_definition_ : public VariableScopes
		{
			static constexpr auto name = "flavor_specialization_type_definition_";

			Variable_flavor_specialization_type_definition_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_type_definition_;
			}

			virtual ~Variable_flavor_specialization_type_definition_() override = default;

			Variable_flavor_specialization_type_definition_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_type_definition_;
			}

			Variable_flavor_specialization_type_definition_&
			operator=(const Variable_flavor_specialization_type_definition_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_specialization_type_definition_case_ : public VariableScopes
		{
			static constexpr auto name = "flavor_specialization_type_definition_case_";

			Variable_flavor_specialization_type_definition_case_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_type_definition_case_;
			}

			virtual ~Variable_flavor_specialization_type_definition_case_() override = default;

			Variable_flavor_specialization_type_definition_case_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_specialization_type_definition_case_;
			}

			Variable_flavor_specialization_type_definition_case_&
			operator=(const Variable_flavor_specialization_type_definition_case_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_type_definition_ : public VariableScopes
		{
			static constexpr auto name = "flavor_type_definition_";

			Variable_flavor_type_definition_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_type_definition_;
			}

			virtual ~Variable_flavor_type_definition_() override = default;

			Variable_flavor_type_definition_(EntryExitListenerTemplate* entryexitlistenertemplate_,
											 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_type_definition_;
			}

			Variable_flavor_type_definition_&
			operator=(const Variable_flavor_type_definition_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_type_definition_default_case_ : public VariableScopes
		{
			static constexpr auto name = "flavor_type_definition_default_case_";

			Variable_flavor_type_definition_default_case_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_type_definition_default_case_;
			}

			virtual ~Variable_flavor_type_definition_default_case_() override = default;

			Variable_flavor_type_definition_default_case_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_type_definition_default_case_;
			}

			Variable_flavor_type_definition_default_case_&
			operator=(const Variable_flavor_type_definition_default_case_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_type_definition_specialization_case_ : public VariableScopes
		{
			static constexpr auto name = "flavor_type_definition_specialization_case_";

			Variable_flavor_type_definition_specialization_case_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_type_definition_specialization_case_;
			}

			virtual ~Variable_flavor_type_definition_specialization_case_() override = default;

			Variable_flavor_type_definition_specialization_case_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					flavor_type_definition_specialization_case_;
			}

			Variable_flavor_type_definition_specialization_case_&
			operator=(const Variable_flavor_type_definition_specialization_case_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_type_name_ : public VariableScopes
		{
			static constexpr auto name = "flavor_type_name_";

			Variable_flavor_type_name_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_type_name_;
			}

			virtual ~Variable_flavor_type_name_() override = default;

			Variable_flavor_type_name_(EntryExitListenerTemplate* entryexitlistenertemplate_,
									   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_type_name_;
			}

			Variable_flavor_type_name_& operator=(const Variable_flavor_type_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavor_value_ : public VariableScopes
		{
			static constexpr auto name = "flavor_value_";

			Variable_flavor_value_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_value_;
			}

			virtual ~Variable_flavor_value_() override = default;

			Variable_flavor_value_(EntryExitListenerTemplate* entryexitlistenertemplate_,
								   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavor_value_;
			}

			Variable_flavor_value_& operator=(const Variable_flavor_value_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_flavoring_name_ : public VariableScopes
		{
			static constexpr auto name = "flavoring_name_";

			Variable_flavoring_name_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavoring_name_;
			}

			virtual ~Variable_flavoring_name_() override = default;

			Variable_flavoring_name_(EntryExitListenerTemplate* entryexitlistenertemplate_,
									 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::flavoring_name_;
			}

			Variable_flavoring_name_& operator=(const Variable_flavoring_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_function_optional_template_argument_ : public VariableScopes
		{
			static constexpr auto name = "function_optional_template_argument_";

			Variable_function_optional_template_argument_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					function_optional_template_argument_;
			}

			virtual ~Variable_function_optional_template_argument_() override = default;

			Variable_function_optional_template_argument_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					function_optional_template_argument_;
			}

			Variable_function_optional_template_argument_&
			operator=(const Variable_function_optional_template_argument_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_function_template_argument_ : public VariableScopes
		{
			static constexpr auto name = "function_template_argument_";

			Variable_function_template_argument_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					function_template_argument_;
			}

			virtual ~Variable_function_template_argument_() override = default;

			Variable_function_template_argument_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					function_template_argument_;
			}

			Variable_function_template_argument_&
			operator=(const Variable_function_template_argument_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_function_template_argument_typename_ : public VariableScopes
		{
			static constexpr auto name = "function_template_argument_typename_";

			Variable_function_template_argument_typename_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					function_template_argument_typename_;
			}

			virtual ~Variable_function_template_argument_typename_() override = default;

			Variable_function_template_argument_typename_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					function_template_argument_typename_;
			}

			Variable_function_template_argument_typename_&
			operator=(const Variable_function_template_argument_typename_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_function_type_ : public VariableScopes
		{
			static constexpr auto name = "function_type_";

			Variable_function_type_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::function_type_;
			}

			virtual ~Variable_function_type_() override = default;

			Variable_function_type_(EntryExitListenerTemplate* entryexitlistenertemplate_,
									const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::function_type_;
			}

			Variable_function_type_& operator=(const Variable_function_type_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_function_type_ls_ : public VariableScopes
		{
			static constexpr auto name = "function_type_ls_";

			Variable_function_type_ls_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::function_type_ls_;
			}

			virtual ~Variable_function_type_ls_() override = default;

			Variable_function_type_ls_(EntryExitListenerTemplate* entryexitlistenertemplate_,
									   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::function_type_ls_;
			}

			Variable_function_type_ls_& operator=(const Variable_function_type_ls_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_header_guard_ : public VariableScopes
		{
			static constexpr auto name = "header_guard_";

			Variable_header_guard_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::header_guard_;
			}

			virtual ~Variable_header_guard_() override = default;

			Variable_header_guard_(EntryExitListenerTemplate* entryexitlistenertemplate_,
								   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::header_guard_;
			}

			Variable_header_guard_& operator=(const Variable_header_guard_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_inherit_ : public VariableScopes
		{
			static constexpr auto name = "inherit_";

			Variable_inherit_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::inherit_;
			}

			virtual ~Variable_inherit_() override = default;

			Variable_inherit_(EntryExitListenerTemplate* entryexitlistenertemplate_,
							  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::inherit_;
			}

			Variable_inherit_& operator=(const Variable_inherit_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_invalidation_add_ : public VariableScopes
		{
			static constexpr auto name = "invalidation_add_";

			Variable_invalidation_add_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::invalidation_add_;
			}

			virtual ~Variable_invalidation_add_() override = default;

			Variable_invalidation_add_(EntryExitListenerTemplate* entryexitlistenertemplate_,
									   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::invalidation_add_;
			}

			Variable_invalidation_add_& operator=(const Variable_invalidation_add_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_invalidation_counter_ : public VariableScopes
		{
			static constexpr auto name = "invalidation_counter_";

			Variable_invalidation_counter_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					invalidation_counter_;
			}

			virtual ~Variable_invalidation_counter_() override = default;

			Variable_invalidation_counter_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					invalidation_counter_;
			}

			Variable_invalidation_counter_&
			operator=(const Variable_invalidation_counter_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_invalidation_remove_ : public VariableScopes
		{
			static constexpr auto name = "invalidation_remove_";

			Variable_invalidation_remove_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::invalidation_remove_;
			}

			virtual ~Variable_invalidation_remove_() override = default;

			Variable_invalidation_remove_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::invalidation_remove_;
			}

			Variable_invalidation_remove_& operator=(const Variable_invalidation_remove_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_is_invalidated_check_ : public VariableScopes
		{
			static constexpr auto name = "is_invalidated_check_";

			Variable_is_invalidated_check_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					is_invalidated_check_;
			}

			virtual ~Variable_is_invalidated_check_() override = default;

			Variable_is_invalidated_check_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					is_invalidated_check_;
			}

			Variable_is_invalidated_check_&
			operator=(const Variable_is_invalidated_check_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_language_name_ : public VariableScopes
		{
			static constexpr auto name = "language_name_";

			Variable_language_name_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::language_name_;
			}

			virtual ~Variable_language_name_() override = default;

			Variable_language_name_(EntryExitListenerTemplate* entryexitlistenertemplate_,
									const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::language_name_;
			}

			Variable_language_name_& operator=(const Variable_language_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_left_angle_bracket_ : public VariableScopes
		{
			static constexpr auto name = "left_angle_bracket_";

			Variable_left_angle_bracket_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::left_angle_bracket_;
			}

			virtual ~Variable_left_angle_bracket_() override = default;

			Variable_left_angle_bracket_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::left_angle_bracket_;
			}

			Variable_left_angle_bracket_& operator=(const Variable_left_angle_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_left_bracket_ : public VariableScopes
		{
			static constexpr auto name = "left_bracket_";

			Variable_left_bracket_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::left_bracket_;
			}

			virtual ~Variable_left_bracket_() override = default;

			Variable_left_bracket_(EntryExitListenerTemplate* entryexitlistenertemplate_,
								   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::left_bracket_;
			}

			Variable_left_bracket_& operator=(const Variable_left_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_left_curly_bracket_ : public VariableScopes
		{
			static constexpr auto name = "left_curly_bracket_";

			Variable_left_curly_bracket_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::left_curly_bracket_;
			}

			virtual ~Variable_left_curly_bracket_() override = default;

			Variable_left_curly_bracket_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::left_curly_bracket_;
			}

			Variable_left_curly_bracket_& operator=(const Variable_left_curly_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_miror_manipulation_ : public VariableScopes
		{
			static constexpr auto name = "miror_manipulation_";

			Variable_miror_manipulation_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::miror_manipulation_;
			}

			virtual ~Variable_miror_manipulation_() override = default;

			Variable_miror_manipulation_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::miror_manipulation_;
			}

			Variable_miror_manipulation_& operator=(const Variable_miror_manipulation_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_object_base_type_ : public VariableScopes
		{
			static constexpr auto name = "object_base_type_";

			Variable_object_base_type_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::object_base_type_;
			}

			virtual ~Variable_object_base_type_() override = default;

			Variable_object_base_type_(EntryExitListenerTemplate* entryexitlistenertemplate_,
									   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::object_base_type_;
			}

			Variable_object_base_type_& operator=(const Variable_object_base_type_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_object_type_ : public VariableScopes
		{
			static constexpr auto name = "object_type_";

			Variable_object_type_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::object_type_;
			}

			virtual ~Variable_object_type_() override = default;

			Variable_object_type_(EntryExitListenerTemplate* entryexitlistenertemplate_,
								  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::object_type_;
			}

			Variable_object_type_& operator=(const Variable_object_type_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_object_type_name_ : public VariableScopes
		{
			static constexpr auto name = "object_type_name_";

			Variable_object_type_name_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::object_type_name_;
			}

			virtual ~Variable_object_type_name_() override = default;

			Variable_object_type_name_(EntryExitListenerTemplate* entryexitlistenertemplate_,
									   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::object_type_name_;
			}

			Variable_object_type_name_& operator=(const Variable_object_type_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_optional_action_pop_ : public VariableScopes
		{
			static constexpr auto name = "optional_action_pop_";

			Variable_optional_action_pop_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::optional_action_pop_;
			}

			virtual ~Variable_optional_action_pop_() override = default;

			Variable_optional_action_pop_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::optional_action_pop_;
			}

			Variable_optional_action_pop_& operator=(const Variable_optional_action_pop_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_optional_action_push_ : public VariableScopes
		{
			static constexpr auto name = "optional_action_push_";

			Variable_optional_action_push_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					optional_action_push_;
			}

			virtual ~Variable_optional_action_push_() override = default;

			Variable_optional_action_push_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					optional_action_push_;
			}

			Variable_optional_action_push_&
			operator=(const Variable_optional_action_push_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_optional_dispatch_mechanic_ : public VariableScopes
		{
			static constexpr auto name = "optional_dispatch_mechanic_";

			Variable_optional_dispatch_mechanic_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					optional_dispatch_mechanic_;
			}

			virtual ~Variable_optional_dispatch_mechanic_() override = default;

			Variable_optional_dispatch_mechanic_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					optional_dispatch_mechanic_;
			}

			Variable_optional_dispatch_mechanic_&
			operator=(const Variable_optional_dispatch_mechanic_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_optional_flavor_action_stack_ : public VariableScopes
		{
			static constexpr auto name = "optional_flavor_action_stack_";

			Variable_optional_flavor_action_stack_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					optional_flavor_action_stack_;
			}

			virtual ~Variable_optional_flavor_action_stack_() override = default;

			Variable_optional_flavor_action_stack_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					optional_flavor_action_stack_;
			}

			Variable_optional_flavor_action_stack_&
			operator=(const Variable_optional_flavor_action_stack_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_optional_invalidation_add_ : public VariableScopes
		{
			static constexpr auto name = "optional_invalidation_add_";

			Variable_optional_invalidation_add_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					optional_invalidation_add_;
			}

			virtual ~Variable_optional_invalidation_add_() override = default;

			Variable_optional_invalidation_add_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					optional_invalidation_add_;
			}

			Variable_optional_invalidation_add_&
			operator=(const Variable_optional_invalidation_add_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_optional_invalidation_counter_ : public VariableScopes
		{
			static constexpr auto name = "optional_invalidation_counter_";

			Variable_optional_invalidation_counter_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					optional_invalidation_counter_;
			}

			virtual ~Variable_optional_invalidation_counter_() override = default;

			Variable_optional_invalidation_counter_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					optional_invalidation_counter_;
			}

			Variable_optional_invalidation_counter_&
			operator=(const Variable_optional_invalidation_counter_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_optional_invalidation_remove_ : public VariableScopes
		{
			static constexpr auto name = "optional_invalidation_remove_";

			Variable_optional_invalidation_remove_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					optional_invalidation_remove_;
			}

			virtual ~Variable_optional_invalidation_remove_() override = default;

			Variable_optional_invalidation_remove_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					optional_invalidation_remove_;
			}

			Variable_optional_invalidation_remove_&
			operator=(const Variable_optional_invalidation_remove_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_optional_is_invalidated_check_ : public VariableScopes
		{
			static constexpr auto name = "optional_is_invalidated_check_";

			Variable_optional_is_invalidated_check_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					optional_is_invalidated_check_;
			}

			virtual ~Variable_optional_is_invalidated_check_() override = default;

			Variable_optional_is_invalidated_check_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					optional_is_invalidated_check_;
			}

			Variable_optional_is_invalidated_check_&
			operator=(const Variable_optional_is_invalidated_check_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_optional_value_ : public VariableScopes
		{
			static constexpr auto name = "optional_value_";

			Variable_optional_value_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::optional_value_;
			}

			virtual ~Variable_optional_value_() override = default;

			Variable_optional_value_(EntryExitListenerTemplate* entryexitlistenertemplate_,
									 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::optional_value_;
			}

			Variable_optional_value_& operator=(const Variable_optional_value_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_output_name_ : public VariableScopes
		{
			static constexpr auto name = "output_name_";

			Variable_output_name_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::output_name_;
			}

			virtual ~Variable_output_name_() override = default;

			Variable_output_name_(EntryExitListenerTemplate* entryexitlistenertemplate_,
								  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::output_name_;
			}

			Variable_output_name_& operator=(const Variable_output_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_right_angle_bracket_ : public VariableScopes
		{
			static constexpr auto name = "right_angle_bracket_";

			Variable_right_angle_bracket_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::right_angle_bracket_;
			}

			virtual ~Variable_right_angle_bracket_() override = default;

			Variable_right_angle_bracket_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::right_angle_bracket_;
			}

			Variable_right_angle_bracket_& operator=(const Variable_right_angle_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_right_bracket_ : public VariableScopes
		{
			static constexpr auto name = "right_bracket_";

			Variable_right_bracket_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::right_bracket_;
			}

			virtual ~Variable_right_bracket_() override = default;

			Variable_right_bracket_(EntryExitListenerTemplate* entryexitlistenertemplate_,
									const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::right_bracket_;
			}

			Variable_right_bracket_& operator=(const Variable_right_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_right_curly_bracket_ : public VariableScopes
		{
			static constexpr auto name = "right_curly_bracket_";

			Variable_right_curly_bracket_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::right_curly_bracket_;
			}

			virtual ~Variable_right_curly_bracket_() override = default;

			Variable_right_curly_bracket_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::right_curly_bracket_;
			}

			Variable_right_curly_bracket_& operator=(const Variable_right_curly_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_sub_member_access_name_ : public VariableScopes
		{
			static constexpr auto name = "sub_member_access_name_";

			Variable_sub_member_access_name_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					sub_member_access_name_;
			}

			virtual ~Variable_sub_member_access_name_() override = default;

			Variable_sub_member_access_name_(EntryExitListenerTemplate* entryexitlistenertemplate_,
											 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					sub_member_access_name_;
			}

			Variable_sub_member_access_name_&
			operator=(const Variable_sub_member_access_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_target_namespace_ : public VariableScopes
		{
			static constexpr auto name = "target_namespace_";

			Variable_target_namespace_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::target_namespace_;
			}

			virtual ~Variable_target_namespace_() override = default;

			Variable_target_namespace_(EntryExitListenerTemplate* entryexitlistenertemplate_,
									   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::target_namespace_;
			}

			Variable_target_namespace_& operator=(const Variable_target_namespace_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_template_base_dispatch_function_ : public VariableScopes
		{
			static constexpr auto name = "template_base_dispatch_function_";

			Variable_template_base_dispatch_function_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					template_base_dispatch_function_;
			}

			virtual ~Variable_template_base_dispatch_function_() override = default;

			Variable_template_base_dispatch_function_(
				EntryExitListenerTemplate* entryexitlistenertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					template_base_dispatch_function_;
			}

			Variable_template_base_dispatch_function_&
			operator=(const Variable_template_base_dispatch_function_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_user_function_section_ : public VariableScopes
		{
			static constexpr auto name = "user_function_section_";

			Variable_user_function_section_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					user_function_section_;
			}

			virtual ~Variable_user_function_section_() override = default;

			Variable_user_function_section_(EntryExitListenerTemplate* entryexitlistenertemplate_,
											const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					user_function_section_;
			}

			Variable_user_function_section_&
			operator=(const Variable_user_function_section_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_user_include_section_ : public VariableScopes
		{
			static constexpr auto name = "user_include_section_";

			Variable_user_include_section_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					user_include_section_;
			}

			virtual ~Variable_user_include_section_() override = default;

			Variable_user_include_section_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::
					user_include_section_;
			}

			Variable_user_include_section_&
			operator=(const Variable_user_include_section_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_user_member_section_ : public VariableScopes
		{
			static constexpr auto name = "user_member_section_";

			Variable_user_member_section_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::user_member_section_;
			}

			virtual ~Variable_user_member_section_() override = default;

			Variable_user_member_section_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::user_member_section_;
			}

			Variable_user_member_section_& operator=(const Variable_user_member_section_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_value_ : public VariableScopes
		{
			static constexpr auto name = "value_";

			Variable_value_() : VariableScopes()
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::value_;
			}

			virtual ~Variable_value_() override = default;

			Variable_value_(EntryExitListenerTemplate* entryexitlistenertemplate_,
							const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::value_;
			}

			Variable_value_& operator=(const Variable_value_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_visit_function_name_ : public VariableScopes
		{
			static constexpr auto name = "visit_function_name_";

			Variable_visit_function_name_() : VariableScopes()
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::visit_function_name_;
			}

			virtual ~Variable_visit_function_name_() override = default;

			Variable_visit_function_name_(EntryExitListenerTemplate* entryexitlistenertemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::fgl::ir::generate::cpp::EntryExitListenerTemplate::Type::visit_function_name_;
			}

			Variable_visit_function_name_& operator=(const Variable_visit_function_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

	public:
		inline static std::vector<VariableBase*> variables_to_delete = std::vector<VariableBase*>();

	public:
		std::vector<VariableBase*> variables_;

	public:
		// Members that one can directly access.
		// e.g. EntryExitListenerTemplate.member = "auto-generated";
		Variable_accept_function_name_* accept_function_name_ =
			new Variable_accept_function_name_();
		Variable_action_id_* action_id_ = new Variable_action_id_();
		Variable_action_pop_* action_pop_ = new Variable_action_pop_();
		Variable_action_push_* action_push_ = new Variable_action_push_();
		Variable_base_dispatch_function_* base_dispatch_function_ =
			new Variable_base_dispatch_function_();
		Variable_class_name_* class_name_ = new Variable_class_name_();
		Variable_class_namespace_* class_namespace_ = new Variable_class_namespace_();
		Variable_const_qualifier_* const_qualifier_ = new Variable_const_qualifier_();
		Variable_constexpr_* constexpr_ = new Variable_constexpr_();
		Variable_dispatch_function_* dispatch_function_ = new Variable_dispatch_function_();
		Variable_dispatch_mechanic_* dispatch_mechanic_ = new Variable_dispatch_mechanic_();
		Variable_enter_function_name_* enter_function_name_ = new Variable_enter_function_name_();
		Variable_enter_function_name_fgl_* enter_function_name_fgl_ =
			new Variable_enter_function_name_fgl_();
		Variable_enter_function_name_legacy_ast_* enter_function_name_legacy_ast_ =
			new Variable_enter_function_name_legacy_ast_();
		Variable_enter_function_name_ls_* enter_function_name_ls_ =
			new Variable_enter_function_name_ls_();
		Variable_entry_cases_* entry_cases_ = new Variable_entry_cases_();
		Variable_entry_conditional_* entry_conditional_ = new Variable_entry_conditional_();
		Variable_entry_manipulation_* entry_manipulation_ = new Variable_entry_manipulation_();
		Variable_entry_node_* entry_node_ = new Variable_entry_node_();
		Variable_entry_object_type_* entry_object_type_ = new Variable_entry_object_type_();
		Variable_exit_cases_* exit_cases_ = new Variable_exit_cases_();
		Variable_exit_function_name_* exit_function_name_ = new Variable_exit_function_name_();
		Variable_exit_function_name_fgl_* exit_function_name_fgl_ =
			new Variable_exit_function_name_fgl_();
		Variable_exit_function_name_legacy_ast_* exit_function_name_legacy_ast_ =
			new Variable_exit_function_name_legacy_ast_();
		Variable_exit_function_name_ls_* exit_function_name_ls_ =
			new Variable_exit_function_name_ls_();
		Variable_exit_node_* exit_node_ = new Variable_exit_node_();
		Variable_exit_object_type_* exit_object_type_ = new Variable_exit_object_type_();
		Variable_file_* file_ = new Variable_file_();
		Variable_flavor_* flavor_ = new Variable_flavor_();
		Variable_flavor_action_stack_* flavor_action_stack_ = new Variable_flavor_action_stack_();
		Variable_flavor_count_type_* flavor_count_type_ = new Variable_flavor_count_type_();
		Variable_flavor_declaration_* flavor_declaration_ = new Variable_flavor_declaration_();
		Variable_flavor_enum_to_type_conversion_* flavor_enum_to_type_conversion_ =
			new Variable_flavor_enum_to_type_conversion_();
		Variable_flavor_enum_to_type_conversion_case_* flavor_enum_to_type_conversion_case_ =
			new Variable_flavor_enum_to_type_conversion_case_();
		Variable_flavor_forward_declaration_* flavor_forward_declaration_ =
			new Variable_flavor_forward_declaration_();
		Variable_flavor_invalidation_type_* flavor_invalidation_type_ =
			new Variable_flavor_invalidation_type_();
		Variable_flavor_name_* flavor_name_ = new Variable_flavor_name_();
		Variable_flavor_specialization_* flavor_specialization_ =
			new Variable_flavor_specialization_();
		Variable_flavor_specialization_case_* flavor_specialization_case_ =
			new Variable_flavor_specialization_case_();
		Variable_flavor_specialization_forward_declaration_*
			flavor_specialization_forward_declaration_ =
				new Variable_flavor_specialization_forward_declaration_();
		Variable_flavor_specialization_member_* flavor_specialization_member_ =
			new Variable_flavor_specialization_member_();
		Variable_flavor_specialization_name_* flavor_specialization_name_ =
			new Variable_flavor_specialization_name_();
		Variable_flavor_specialization_type_* flavor_specialization_type_ =
			new Variable_flavor_specialization_type_();
		Variable_flavor_specialization_type_conversion_* flavor_specialization_type_conversion_ =
			new Variable_flavor_specialization_type_conversion_();
		Variable_flavor_specialization_type_definition_* flavor_specialization_type_definition_ =
			new Variable_flavor_specialization_type_definition_();
		Variable_flavor_specialization_type_definition_case_*
			flavor_specialization_type_definition_case_ =
				new Variable_flavor_specialization_type_definition_case_();
		Variable_flavor_type_definition_* flavor_type_definition_ =
			new Variable_flavor_type_definition_();
		Variable_flavor_type_definition_default_case_* flavor_type_definition_default_case_ =
			new Variable_flavor_type_definition_default_case_();
		Variable_flavor_type_definition_specialization_case_*
			flavor_type_definition_specialization_case_ =
				new Variable_flavor_type_definition_specialization_case_();
		Variable_flavor_type_name_* flavor_type_name_ = new Variable_flavor_type_name_();
		Variable_flavor_value_* flavor_value_ = new Variable_flavor_value_();
		Variable_flavoring_name_* flavoring_name_ = new Variable_flavoring_name_();
		Variable_function_optional_template_argument_* function_optional_template_argument_ =
			new Variable_function_optional_template_argument_();
		Variable_function_template_argument_* function_template_argument_ =
			new Variable_function_template_argument_();
		Variable_function_template_argument_typename_* function_template_argument_typename_ =
			new Variable_function_template_argument_typename_();
		Variable_function_type_* function_type_ = new Variable_function_type_();
		Variable_function_type_ls_* function_type_ls_ = new Variable_function_type_ls_();
		Variable_header_guard_* header_guard_ = new Variable_header_guard_();
		Variable_inherit_* inherit_ = new Variable_inherit_();
		Variable_invalidation_add_* invalidation_add_ = new Variable_invalidation_add_();
		Variable_invalidation_counter_* invalidation_counter_ =
			new Variable_invalidation_counter_();
		Variable_invalidation_remove_* invalidation_remove_ = new Variable_invalidation_remove_();
		Variable_is_invalidated_check_* is_invalidated_check_ =
			new Variable_is_invalidated_check_();
		Variable_language_name_* language_name_ = new Variable_language_name_();
		Variable_left_angle_bracket_* left_angle_bracket_ = new Variable_left_angle_bracket_();
		Variable_left_bracket_* left_bracket_ = new Variable_left_bracket_();
		Variable_left_curly_bracket_* left_curly_bracket_ = new Variable_left_curly_bracket_();
		Variable_miror_manipulation_* miror_manipulation_ = new Variable_miror_manipulation_();
		Variable_object_base_type_* object_base_type_ = new Variable_object_base_type_();
		Variable_object_type_* object_type_ = new Variable_object_type_();
		Variable_object_type_name_* object_type_name_ = new Variable_object_type_name_();
		Variable_optional_action_pop_* optional_action_pop_ = new Variable_optional_action_pop_();
		Variable_optional_action_push_* optional_action_push_ =
			new Variable_optional_action_push_();
		Variable_optional_dispatch_mechanic_* optional_dispatch_mechanic_ =
			new Variable_optional_dispatch_mechanic_();
		Variable_optional_flavor_action_stack_* optional_flavor_action_stack_ =
			new Variable_optional_flavor_action_stack_();
		Variable_optional_invalidation_add_* optional_invalidation_add_ =
			new Variable_optional_invalidation_add_();
		Variable_optional_invalidation_counter_* optional_invalidation_counter_ =
			new Variable_optional_invalidation_counter_();
		Variable_optional_invalidation_remove_* optional_invalidation_remove_ =
			new Variable_optional_invalidation_remove_();
		Variable_optional_is_invalidated_check_* optional_is_invalidated_check_ =
			new Variable_optional_is_invalidated_check_();
		Variable_optional_value_* optional_value_ = new Variable_optional_value_();
		Variable_output_name_* output_name_ = new Variable_output_name_();
		Variable_right_angle_bracket_* right_angle_bracket_ = new Variable_right_angle_bracket_();
		Variable_right_bracket_* right_bracket_ = new Variable_right_bracket_();
		Variable_right_curly_bracket_* right_curly_bracket_ = new Variable_right_curly_bracket_();
		Variable_sub_member_access_name_* sub_member_access_name_ =
			new Variable_sub_member_access_name_();
		Variable_target_namespace_* target_namespace_ = new Variable_target_namespace_();
		Variable_template_base_dispatch_function_* template_base_dispatch_function_ =
			new Variable_template_base_dispatch_function_();
		Variable_user_function_section_* user_function_section_ =
			new Variable_user_function_section_();
		Variable_user_include_section_* user_include_section_ =
			new Variable_user_include_section_();
		Variable_user_member_section_* user_member_section_ = new Variable_user_member_section_();
		Variable_value_* value_ = new Variable_value_();
		Variable_visit_function_name_* visit_function_name_ = new Variable_visit_function_name_();

	public:
		EntryExitListenerTemplate()
		{
			*accept_function_name_ = Variable_accept_function_name_(
				this, std::vector<VariableBase*>({GenerateVariable("Accept")}));
			*action_id_ = Variable_action_id_(this, std::vector<VariableBase*>({}));
			*action_pop_ = Variable_action_pop_(
				this,
				std::vector<VariableBase*>({GenerateVariable("flavorActionStack"),
											GenerateVariable("."), GenerateVariable("pop();")}));
			*action_push_ = Variable_action_push_(
				this, std::vector<VariableBase*>({GenerateVariable("flavorActionStack"),
												  GenerateVariable("."), GenerateVariable("push("),
												  GenerateVariable(action_id_->This()),
												  GenerateVariable(");")}));
			*base_dispatch_function_ = Variable_base_dispatch_function_(
				this,
				std::vector<VariableBase*>({GenerateVariable("\nvoid "),
											GenerateVariable(visit_function_name_->This()),
											GenerateVariable("("),
											GenerateVariable(target_namespace_->This()),
											GenerateVariable("::"),
											GenerateVariable(object_base_type_->This()),
											GenerateVariable("* node)\n"),
											GenerateVariable("{"),
											GenerateVariable("\n\tfor (auto* subNode : node-"),
											GenerateVariable(right_angle_bracket_->This()),
											GenerateVariable(sub_member_access_name_->This()),
											GenerateVariable(")\n\t"),
											GenerateVariable("{"),
											GenerateVariable("\n\t\tsubNode-"),
											GenerateVariable(right_angle_bracket_->This()),
											GenerateVariable(accept_function_name_->This()),
											GenerateVariable("(this);\n\t"),
											GenerateVariable("}"),
											GenerateVariable("\n"),
											GenerateVariable("}")}));
			*class_name_ = Variable_class_name_(this, std::vector<VariableBase*>({}));
			*class_namespace_ = Variable_class_namespace_(this, std::vector<VariableBase*>({}));
			*const_qualifier_ = Variable_const_qualifier_(
				this, std::vector<VariableBase*>({GenerateVariable("const")}));
			*constexpr_ = Variable_constexpr_(
				this, std::vector<VariableBase*>({GenerateVariable("constexpr")}));
			*dispatch_function_ = Variable_dispatch_function_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("\nvoid "),
						   GenerateVariable(visit_function_name_->This()),
						   GenerateVariable("("),
						   GenerateVariable(target_namespace_->This()),
						   GenerateVariable("::"),
						   GenerateVariable(object_type_->This()),
						   GenerateVariable("* node)\n"),
						   GenerateVariable("{"),
						   GenerateVariable("\n\t"),
						   GenerateVariable(entry_object_type_->This()),
						   GenerateVariable("(node);\n\n\tfor (auto* subNode : node-"),
						   GenerateVariable(right_angle_bracket_->This()),
						   GenerateVariable(sub_member_access_name_->This()),
						   GenerateVariable(")\n\t"),
						   GenerateVariable("{"),
						   GenerateVariable("\n\t\tsubNode-"),
						   GenerateVariable(right_angle_bracket_->This()),
						   GenerateVariable(accept_function_name_->This()),
						   GenerateVariable("(this);\n\t"),
						   GenerateVariable("}"),
						   GenerateVariable("\n\t\n\t"),
						   GenerateVariable(exit_object_type_->This()),
						   GenerateVariable("(node);\n"),
						   GenerateVariable("}")}));
			*dispatch_mechanic_ = Variable_dispatch_mechanic_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("\n\tprivate:\n\t\t// Dispatch function\n\t\t"),
						   GenerateVariable(template_base_dispatch_function_->This()),
						   GenerateVariable("\n\n\t\t// Subtype dispatch functions\n\t\t"),
						   GenerateVariable(dispatch_function_->Variable_Field()),
						   GenerateVariable("\n")}));
			*enter_function_name_ = Variable_enter_function_name_(
				this,
				std::vector<VariableBase*>({GenerateVariable(enter_function_name_ls_->This())}));
			*enter_function_name_fgl_ = Variable_enter_function_name_fgl_(
				this, std::vector<VariableBase*>({GenerateVariable("Entry"),
												  GenerateVariable(object_type_name_->This())}));
			*enter_function_name_legacy_ast_ = Variable_enter_function_name_legacy_ast_(
				this, std::vector<VariableBase*>({GenerateVariable("ListenEntry")}));
			*enter_function_name_ls_ = Variable_enter_function_name_ls_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("Enter<::"), GenerateVariable(language_name_->This()),
						   GenerateVariable("::ls::definition::Logical::"),
						   GenerateVariable(object_type_name_->This()), GenerateVariable(">")}));
			*entry_cases_ = Variable_entry_cases_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("if ("), GenerateVariable(entry_conditional_->This()),
					 GenerateVariable(")\n"), GenerateVariable("{"), GenerateVariable("\n\t"),
					 GenerateVariable(entry_manipulation_->This()), GenerateVariable("\n\n\t"),
					 GenerateVariable(optional_action_push_->This()),
					 GenerateVariable("\n\n\treturn;\n"), GenerateVariable("}")}));
			*entry_conditional_ = Variable_entry_conditional_(this, std::vector<VariableBase*>({}));
			*entry_manipulation_ =
				Variable_entry_manipulation_(this, std::vector<VariableBase*>({}));
			*entry_node_ = Variable_entry_node_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("void "), GenerateVariable(entry_object_type_->This()),
					 GenerateVariable("("), GenerateVariable(function_type_->This()),
					 GenerateVariable(" node)\n"), GenerateVariable("{"), GenerateVariable("\n\t"),
					 GenerateVariable(entry_cases_->Variable_Field()),
					 GenerateVariable("\n\n\t// Uncaptured part"), GenerateVariable("."),
					 GenerateVariable("\n"), GenerateVariable("}")}));
			*entry_object_type_ = Variable_entry_object_type_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable(enter_function_name_->This()),
						   GenerateVariable(function_optional_template_argument_->This())}));
			*exit_cases_ = Variable_exit_cases_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("if ("), GenerateVariable(action_id_->This()),
					 GenerateVariable(" == flavorActionStack"), GenerateVariable("."),
					 GenerateVariable("top())\n"), GenerateVariable("{"), GenerateVariable("\n\t"),
					 GenerateVariable(miror_manipulation_->This()), GenerateVariable("\n\n\t"),
					 GenerateVariable(optional_action_pop_->This()),
					 GenerateVariable("\n\n\treturn;\n"), GenerateVariable("}")}));
			*exit_function_name_ = Variable_exit_function_name_(
				this, std::vector<VariableBase*>({GenerateVariable("Exit")}));
			*exit_function_name_fgl_ = Variable_exit_function_name_fgl_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("Exit"), GenerateVariable(object_type_name_->This())}));
			*exit_function_name_legacy_ast_ = Variable_exit_function_name_legacy_ast_(
				this, std::vector<VariableBase*>({GenerateVariable("ListenExit")}));
			*exit_function_name_ls_ = Variable_exit_function_name_ls_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("Exit<::"), GenerateVariable(language_name_->This()),
						   GenerateVariable("::ls::definition::Logical::"),
						   GenerateVariable(object_type_name_->This()), GenerateVariable(">")}));
			*exit_node_ = Variable_exit_node_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("void "), GenerateVariable(exit_object_type_->This()),
					 GenerateVariable("("), GenerateVariable(function_type_->This()),
					 GenerateVariable(" node)\n"), GenerateVariable("{"), GenerateVariable("\n\t"),
					 GenerateVariable(exit_cases_->Variable_Field()), GenerateVariable("\n"),
					 GenerateVariable("}")}));
			*exit_object_type_ = Variable_exit_object_type_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable(exit_function_name_->This()),
						   GenerateVariable(function_optional_template_argument_->This())}));
			*file_ = Variable_file_(this, std::vector<VariableBase*>({}));
			*flavor_ = Variable_flavor_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("\nstruct "),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("\n"),
						   GenerateVariable("{"),
						   GenerateVariable("\npublic:\n\t"),
						   GenerateVariable(optional_value_->This()),
						   GenerateVariable("\n\n\t// Counters\n\t"),
						   GenerateVariable(flavor_count_type_->This()),
						   GenerateVariable(" count = 0;\n\npublic:\n\t// Compile time known "
											"possible flavor specializations\n\t"),
						   GenerateVariable(flavor_specialization_member_->Variable_Field()),
						   GenerateVariable(
							   "\n\n\t// Run-time possible flavor specializations\n\npublic:\n\t"),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("() = default;\n\t~"),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("() = default;\n\n\t"),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("(const "),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("&) = delete;\n\t"),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("("),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("&&) noexcept = delete;\n\n\t"),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("& operator=(const "),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("&) = delete;\n\t"),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("& operator=("),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("&&) noexcept = delete;\n\npublic:\n\ttemplate"),
						   GenerateVariable(left_angle_bracket_->This()),
						   GenerateVariable(flavor_type_name_->This()),
						   GenerateVariable(" type"),
						   GenerateVariable(right_angle_bracket_->This()),
						   GenerateVariable("\n\ttypename "),
						   GenerateVariable(flavor_specialization_type_conversion_->This()),
						   GenerateVariable(left_angle_bracket_->This()),
						   GenerateVariable("type"),
						   GenerateVariable(right_angle_bracket_->This()),
						   GenerateVariable("::type& Get()\n\t"),
						   GenerateVariable("{"),
						   GenerateVariable("\n\t\t"),
						   GenerateVariable(flavor_specialization_case_->Variable_Field()),
						   GenerateVariable("\n\n\t\treturn "),
						   GenerateVariable("{"),
						   GenerateVariable("}"),
						   GenerateVariable(";\n\t"),
						   GenerateVariable("}"),
						   GenerateVariable("\n\n\ttemplate"),
						   GenerateVariable(left_angle_bracket_->This()),
						   GenerateVariable(flavor_type_name_->This()),
						   GenerateVariable(" type"),
						   GenerateVariable(right_angle_bracket_->This()),
						   GenerateVariable("\n\tvoid Add()\n\t"),
						   GenerateVariable("{"),
						   GenerateVariable("\n\t\t"),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("::count += 1;\n\t\t"),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("::Get"),
						   GenerateVariable(left_angle_bracket_->This()),
						   GenerateVariable("type"),
						   GenerateVariable(right_angle_bracket_->This()),
						   GenerateVariable("()"),
						   GenerateVariable("."),
						   GenerateVariable("Add();\n\t"),
						   GenerateVariable("}"),
						   GenerateVariable("\n\n\tvoid Add()\n\t"),
						   GenerateVariable("{"),
						   GenerateVariable("\n\t\t"),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("::count += 1;\n\t"),
						   GenerateVariable("}"),
						   GenerateVariable("\n\t\n\ttemplate"),
						   GenerateVariable(left_angle_bracket_->This()),
						   GenerateVariable(flavor_type_name_->This()),
						   GenerateVariable(" type"),
						   GenerateVariable(right_angle_bracket_->This()),
						   GenerateVariable("\n\tvoid Remove()\n\t"),
						   GenerateVariable("{"),
						   GenerateVariable("\n\t\t"),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("::count -= 1;\n\t\t"),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("::Get"),
						   GenerateVariable(left_angle_bracket_->This()),
						   GenerateVariable("type"),
						   GenerateVariable(right_angle_bracket_->This()),
						   GenerateVariable("()"),
						   GenerateVariable("."),
						   GenerateVariable("Remove();\n\t"),
						   GenerateVariable("}"),
						   GenerateVariable("\n\n\tvoid Remove()\n\t"),
						   GenerateVariable("{"),
						   GenerateVariable("\n\t\t"),
						   GenerateVariable(flavor_name_->This()),
						   GenerateVariable("::count -= 1;\n\t"),
						   GenerateVariable("}"),
						   GenerateVariable("\n"),
						   GenerateVariable("}"),
						   GenerateVariable(";")}));
			*flavor_action_stack_ = Variable_flavor_action_stack_(
				this, std::vector<VariableBase*>({GenerateVariable("::std::stack"),
												  GenerateVariable(left_angle_bracket_->This()),
												  GenerateVariable("::std::size_t"),
												  GenerateVariable(right_angle_bracket_->This()),
												  GenerateVariable(" flavorActionStack;")}));
			*flavor_count_type_ = Variable_flavor_count_type_(
				this, std::vector<VariableBase*>({GenerateVariable("int")}));
			*flavor_declaration_ = Variable_flavor_declaration_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable(flavor_name_->This()), GenerateVariable(" "),
						   GenerateVariable(flavor_name_->This()), GenerateVariable(";")}));
			*flavor_enum_to_type_conversion_ = Variable_flavor_enum_to_type_conversion_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\ntemplate"), GenerateVariable(left_angle_bracket_->This()),
					 GenerateVariable(flavor_type_name_->This()), GenerateVariable(" type"),
					 GenerateVariable(right_angle_bracket_->This()), GenerateVariable("\nstruct "),
					 GenerateVariable(flavor_name_->This()), GenerateVariable("EnumToType\n"),
					 GenerateVariable("{"), GenerateVariable("\n\tusing type = void;\n"),
					 GenerateVariable("}"), GenerateVariable(";\n\n"),
					 GenerateVariable(flavor_enum_to_type_conversion_case_->Variable_Field())}));
			*flavor_enum_to_type_conversion_case_ = Variable_flavor_enum_to_type_conversion_case_(
				this,
				std::vector<VariableBase*>({GenerateVariable("template"),
											GenerateVariable(left_angle_bracket_->This()),
											GenerateVariable(right_angle_bracket_->This()),
											GenerateVariable("\nstruct "),
											GenerateVariable(flavor_name_->This()),
											GenerateVariable("EnumToType"),
											GenerateVariable(left_angle_bracket_->This()),
											GenerateVariable(flavor_type_name_->This()),
											GenerateVariable("::"),
											GenerateVariable(flavor_name_->This()),
											GenerateVariable("_"),
											GenerateVariable(flavor_specialization_name_->This()),
											GenerateVariable(right_angle_bracket_->This()),
											GenerateVariable("\n"),
											GenerateVariable("{"),
											GenerateVariable("\n\tusing type = "),
											GenerateVariable(flavor_specialization_name_->This()),
											GenerateVariable(";\n"),
											GenerateVariable("}"),
											GenerateVariable(";")}));
			*flavor_forward_declaration_ = Variable_flavor_forward_declaration_(
				this, std::vector<VariableBase*>({GenerateVariable("struct "),
												  GenerateVariable(flavor_name_->This()),
												  GenerateVariable(";")}));
			*flavor_invalidation_type_ = Variable_flavor_invalidation_type_(
				this, std::vector<VariableBase*>({GenerateVariable("unsigned int")}));
			*flavor_name_ = Variable_flavor_name_(this, std::vector<VariableBase*>({}));
			*flavor_specialization_ = Variable_flavor_specialization_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("\nstruct "),
						   GenerateVariable(flavor_specialization_name_->This()),
						   GenerateVariable("\n"),
						   GenerateVariable("{"),
						   GenerateVariable("\npublic:\n\t"),
						   GenerateVariable(optional_value_->This()),
						   GenerateVariable("\n\n\t// Counters\n\t"),
						   GenerateVariable(flavor_count_type_->This()),
						   GenerateVariable(" count = 0;\n\npublic:\n\t"),
						   GenerateVariable(flavor_specialization_name_->This()),
						   GenerateVariable("() = default;\n\t~"),
						   GenerateVariable(flavor_specialization_name_->This()),
						   GenerateVariable("() = default;\n\n\t"),
						   GenerateVariable(flavor_specialization_name_->This()),
						   GenerateVariable("(const "),
						   GenerateVariable(flavor_specialization_name_->This()),
						   GenerateVariable("&) = delete;\n\t"),
						   GenerateVariable(flavor_specialization_name_->This()),
						   GenerateVariable("("),
						   GenerateVariable(flavor_specialization_name_->This()),
						   GenerateVariable("&&) noexcept = delete;\n\n\t"),
						   GenerateVariable(flavor_specialization_name_->This()),
						   GenerateVariable("& operator=(const "),
						   GenerateVariable(flavor_specialization_name_->This()),
						   GenerateVariable("&) = delete;\n\t"),
						   GenerateVariable(flavor_specialization_name_->This()),
						   GenerateVariable("& operator=("),
						   GenerateVariable(flavor_specialization_name_->This()),
						   GenerateVariable("&&) noexcept = delete;\n\npublic:\n\tvoid Add()\n\t"),
						   GenerateVariable("{"),
						   GenerateVariable("\n\t\t"),
						   GenerateVariable(flavor_specialization_name_->This()),
						   GenerateVariable("::count += 1;\n\t"),
						   GenerateVariable("}"),
						   GenerateVariable("\n\n\tvoid Remove()\n\t"),
						   GenerateVariable("{"),
						   GenerateVariable("\n\t\t"),
						   GenerateVariable(flavor_specialization_name_->This()),
						   GenerateVariable("::count -= 1;\n\t"),
						   GenerateVariable("}"),
						   GenerateVariable("\n"),
						   GenerateVariable("}"),
						   GenerateVariable(";")}));
			*flavor_specialization_case_ = Variable_flavor_specialization_case_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\nif "), GenerateVariable(constexpr_->This()),
					 GenerateVariable(" (type == "), GenerateVariable(flavor_type_name_->This()),
					 GenerateVariable("::"), GenerateVariable(flavor_name_->This()),
					 GenerateVariable("_"), GenerateVariable(flavor_specialization_name_->This()),
					 GenerateVariable(")\n"), GenerateVariable("{"),
					 GenerateVariable("\n\treturn "), GenerateVariable(flavor_name_->This()),
					 GenerateVariable("::"), GenerateVariable(flavor_specialization_name_->This()),
					 GenerateVariable(";\n"), GenerateVariable("}")}));
			*flavor_specialization_forward_declaration_ =
				Variable_flavor_specialization_forward_declaration_(
					this, std::vector<VariableBase*>(
							  {GenerateVariable("struct "),
							   GenerateVariable(flavor_specialization_name_->This()),
							   GenerateVariable(";")}));
			*flavor_specialization_member_ = Variable_flavor_specialization_member_(
				this,
				std::vector<VariableBase*>({GenerateVariable(flavor_specialization_name_->This()),
											GenerateVariable(" "),
											GenerateVariable(flavor_specialization_name_->This()),
											GenerateVariable(";")}));
			*flavor_specialization_name_ =
				Variable_flavor_specialization_name_(this, std::vector<VariableBase*>({}));
			*flavor_specialization_type_ = Variable_flavor_specialization_type_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable(flavor_type_name_->This()), GenerateVariable("::"),
						   GenerateVariable(flavor_specialization_name_->This())}));
			*flavor_specialization_type_conversion_ =
				Variable_flavor_specialization_type_conversion_(
					this, std::vector<VariableBase*>({GenerateVariable(flavor_name_->This()),
													  GenerateVariable("EnumToType")}));
			*flavor_specialization_type_definition_ =
				Variable_flavor_specialization_type_definition_(
					this,
					std::vector<VariableBase*>(
						{GenerateVariable("enum class "),
						 GenerateVariable(flavor_type_name_->This()), GenerateVariable("\n"),
						 GenerateVariable("{"),
						 GenerateVariable(
							 "\n\t// Reserved values\n\tFGL_RESERVED_Unknown = 0,\n\n\t"),
						 GenerateVariable(
							 flavor_specialization_type_definition_case_->Variable_Field()),
						 GenerateVariable("\n"), GenerateVariable("}"), GenerateVariable(";")}));
			*flavor_specialization_type_definition_case_ =
				Variable_flavor_specialization_type_definition_case_(
					this, std::vector<VariableBase*>({GenerateVariable(
							  flavor_type_definition_specialization_case_->This())}));
			*flavor_type_definition_ = Variable_flavor_type_definition_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("\nenum class FlavorType\n"), GenerateVariable("{"),
						   GenerateVariable("\n\t// Reserved values\n\tFGL_RESERVED_Unknown = "
											"0,\n\n\t// Default cases\n\t"),
						   GenerateVariable(flavor_type_definition_default_case_->Variable_Field()),
						   GenerateVariable("\n\n\t// Flavor specialization cases\n\t"),
						   GenerateVariable(
							   flavor_type_definition_specialization_case_->Variable_Field()),
						   GenerateVariable("\n"), GenerateVariable("}"), GenerateVariable(";")}));
			*flavor_type_definition_default_case_ = Variable_flavor_type_definition_default_case_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable(flavor_name_->This()), GenerateVariable(",")}));
			*flavor_type_definition_specialization_case_ =
				Variable_flavor_type_definition_specialization_case_(
					this, std::vector<VariableBase*>(
							  {GenerateVariable(flavor_name_->This()), GenerateVariable("_"),
							   GenerateVariable(flavor_specialization_name_->This()),
							   GenerateVariable(",")}));
			*flavor_type_name_ = Variable_flavor_type_name_(
				this, std::vector<VariableBase*>({GenerateVariable(flavor_name_->This()),
												  GenerateVariable("SpecializationType")}));
			*flavor_value_ = Variable_flavor_value_(
				this, std::vector<VariableBase*>({GenerateVariable("FlavorValue")}));
			*flavoring_name_ = Variable_flavoring_name_(
				this, std::vector<VariableBase*>({GenerateVariable("Flavoring")}));
			*function_optional_template_argument_ =
				Variable_function_optional_template_argument_(this, std::vector<VariableBase*>({}));
			*function_template_argument_ = Variable_function_template_argument_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("<"),
						   GenerateVariable(function_template_argument_typename_->This()),
						   GenerateVariable(">")}));
			*function_template_argument_typename_ =
				Variable_function_template_argument_typename_(this, std::vector<VariableBase*>({}));
			*function_type_ = Variable_function_type_(this, std::vector<VariableBase*>({}));
			*function_type_ls_ = Variable_function_type_ls_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("::"), GenerateVariable(language_name_->This()),
						   GenerateVariable("::ls::traversion::GeneralTraversal<::"),
						   GenerateVariable(language_name_->This()),
						   GenerateVariable("::ls::definition::Logical::"),
						   GenerateVariable(object_type_name_->This()), GenerateVariable(">")}));
			*header_guard_ = Variable_header_guard_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("FGL_"), GenerateVariable(flavoring_name_->Upper()),
						   GenerateVariable("_"), GenerateVariable(output_name_->Upper()),
						   GenerateVariable("_H")}));
			*inherit_ = Variable_inherit_(this, std::vector<VariableBase*>({}));
			*invalidation_add_ = Variable_invalidation_add_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("\nvoid Invalidate()\n"), GenerateVariable("{"),
						   GenerateVariable("\n\tFlavorStackMemory::invalidation += 1;\n"),
						   GenerateVariable("}")}));
			*invalidation_counter_ = Variable_invalidation_counter_(
				this,
				std::vector<VariableBase*>({GenerateVariable(flavor_invalidation_type_->This()),
											GenerateVariable(" invalidation = 0;")}));
			*invalidation_remove_ = Variable_invalidation_remove_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("\nvoid Validate()\n"), GenerateVariable("{"),
						   GenerateVariable("\n\tFlavorStackMemory::invalidation -= 1;\n"),
						   GenerateVariable("}")}));
			*is_invalidated_check_ = Variable_is_invalidated_check_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("\nbool IsInvalidate()\n"), GenerateVariable("{"),
						   GenerateVariable("\n\treturn FlavorStackMemory::invalidation "),
						   GenerateVariable(right_angle_bracket_->This()),
						   GenerateVariable(" 0;\n"), GenerateVariable("}")}));
			*language_name_ = Variable_language_name_(this, std::vector<VariableBase*>({}));
			*left_angle_bracket_ = Variable_left_angle_bracket_(
				this, std::vector<VariableBase*>({GenerateVariable("<")}));
			*left_bracket_ =
				Variable_left_bracket_(this, std::vector<VariableBase*>({GenerateVariable("{")}));
			*left_curly_bracket_ = Variable_left_curly_bracket_(
				this, std::vector<VariableBase*>({GenerateVariable("(")}));
			*miror_manipulation_ =
				Variable_miror_manipulation_(this, std::vector<VariableBase*>({}));
			*object_base_type_ = Variable_object_base_type_(this, std::vector<VariableBase*>({}));
			*object_type_ = Variable_object_type_(this, std::vector<VariableBase*>({}));
			*object_type_name_ = Variable_object_type_name_(this, std::vector<VariableBase*>({}));
			*optional_action_pop_ = Variable_optional_action_pop_(
				this, std::vector<VariableBase*>({GenerateVariable(action_pop_->This())}));
			*optional_action_push_ = Variable_optional_action_push_(
				this, std::vector<VariableBase*>({GenerateVariable(action_push_->This())}));
			*optional_dispatch_mechanic_ =
				Variable_optional_dispatch_mechanic_(this, std::vector<VariableBase*>({}));
			*optional_flavor_action_stack_ = Variable_optional_flavor_action_stack_(
				this, std::vector<VariableBase*>({GenerateVariable(flavor_action_stack_->This())}));
			*optional_invalidation_add_ = Variable_optional_invalidation_add_(
				this, std::vector<VariableBase*>({GenerateVariable(invalidation_add_->This())}));
			*optional_invalidation_counter_ = Variable_optional_invalidation_counter_(
				this,
				std::vector<VariableBase*>({GenerateVariable(invalidation_counter_->This())}));
			*optional_invalidation_remove_ = Variable_optional_invalidation_remove_(
				this, std::vector<VariableBase*>({GenerateVariable(invalidation_remove_->This())}));
			*optional_is_invalidated_check_ = Variable_optional_is_invalidated_check_(
				this,
				std::vector<VariableBase*>({GenerateVariable(is_invalidated_check_->This())}));
			*optional_value_ = Variable_optional_value_(
				this, std::vector<VariableBase*>({GenerateVariable(value_->This())}));
			*output_name_ = Variable_output_name_(this, std::vector<VariableBase*>({}));
			*right_angle_bracket_ = Variable_right_angle_bracket_(
				this, std::vector<VariableBase*>({GenerateVariable(">")}));
			*right_bracket_ =
				Variable_right_bracket_(this, std::vector<VariableBase*>({GenerateVariable("}")}));
			*right_curly_bracket_ = Variable_right_curly_bracket_(
				this, std::vector<VariableBase*>({GenerateVariable(")")}));
			*sub_member_access_name_ = Variable_sub_member_access_name_(
				this, std::vector<VariableBase*>({GenerateVariable("GetNodes()")}));
			*target_namespace_ = Variable_target_namespace_(this, std::vector<VariableBase*>({}));
			*template_base_dispatch_function_ = Variable_template_base_dispatch_function_(
				this,
				std::vector<VariableBase*>({GenerateVariable("\ntemplate"),
											GenerateVariable(left_angle_bracket_->This()),
											GenerateVariable("typename T"),
											GenerateVariable(right_angle_bracket_->This()),
											GenerateVariable("\nvoid "),
											GenerateVariable(visit_function_name_->This()),
											GenerateVariable("(T* node)\n"),
											GenerateVariable("{"),
											GenerateVariable("\n\tfor (auto* subNode : node-"),
											GenerateVariable(right_angle_bracket_->This()),
											GenerateVariable(sub_member_access_name_->This()),
											GenerateVariable(")\n\t"),
											GenerateVariable("{"),
											GenerateVariable("\n\t\tsubNode-"),
											GenerateVariable(right_angle_bracket_->This()),
											GenerateVariable(accept_function_name_->This()),
											GenerateVariable("(this);\n\t"),
											GenerateVariable("}"),
											GenerateVariable("\n"),
											GenerateVariable("}")}));
			*user_function_section_ =
				Variable_user_function_section_(this, std::vector<VariableBase*>({}));
			*user_include_section_ =
				Variable_user_include_section_(this, std::vector<VariableBase*>({}));
			*user_member_section_ =
				Variable_user_member_section_(this, std::vector<VariableBase*>({}));
			*value_ = Variable_value_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable(flavor_value_->This()), GenerateVariable(" value;")}));
			*visit_function_name_ = Variable_visit_function_name_(
				this, std::vector<VariableBase*>({GenerateVariable("Dispatch")}));

			variables_.emplace_back(accept_function_name_);
			variables_.emplace_back(action_id_);
			variables_.emplace_back(action_pop_);
			variables_.emplace_back(action_push_);
			variables_.emplace_back(base_dispatch_function_);
			variables_.emplace_back(class_name_);
			variables_.emplace_back(class_namespace_);
			variables_.emplace_back(const_qualifier_);
			variables_.emplace_back(constexpr_);
			variables_.emplace_back(dispatch_function_);
			variables_.emplace_back(dispatch_mechanic_);
			variables_.emplace_back(enter_function_name_);
			variables_.emplace_back(enter_function_name_fgl_);
			variables_.emplace_back(enter_function_name_legacy_ast_);
			variables_.emplace_back(enter_function_name_ls_);
			variables_.emplace_back(entry_cases_);
			variables_.emplace_back(entry_conditional_);
			variables_.emplace_back(entry_manipulation_);
			variables_.emplace_back(entry_node_);
			variables_.emplace_back(entry_object_type_);
			variables_.emplace_back(exit_cases_);
			variables_.emplace_back(exit_function_name_);
			variables_.emplace_back(exit_function_name_fgl_);
			variables_.emplace_back(exit_function_name_legacy_ast_);
			variables_.emplace_back(exit_function_name_ls_);
			variables_.emplace_back(exit_node_);
			variables_.emplace_back(exit_object_type_);
			variables_.emplace_back(file_);
			variables_.emplace_back(flavor_);
			variables_.emplace_back(flavor_action_stack_);
			variables_.emplace_back(flavor_count_type_);
			variables_.emplace_back(flavor_declaration_);
			variables_.emplace_back(flavor_enum_to_type_conversion_);
			variables_.emplace_back(flavor_enum_to_type_conversion_case_);
			variables_.emplace_back(flavor_forward_declaration_);
			variables_.emplace_back(flavor_invalidation_type_);
			variables_.emplace_back(flavor_name_);
			variables_.emplace_back(flavor_specialization_);
			variables_.emplace_back(flavor_specialization_case_);
			variables_.emplace_back(flavor_specialization_forward_declaration_);
			variables_.emplace_back(flavor_specialization_member_);
			variables_.emplace_back(flavor_specialization_name_);
			variables_.emplace_back(flavor_specialization_type_);
			variables_.emplace_back(flavor_specialization_type_conversion_);
			variables_.emplace_back(flavor_specialization_type_definition_);
			variables_.emplace_back(flavor_specialization_type_definition_case_);
			variables_.emplace_back(flavor_type_definition_);
			variables_.emplace_back(flavor_type_definition_default_case_);
			variables_.emplace_back(flavor_type_definition_specialization_case_);
			variables_.emplace_back(flavor_type_name_);
			variables_.emplace_back(flavor_value_);
			variables_.emplace_back(flavoring_name_);
			variables_.emplace_back(function_optional_template_argument_);
			variables_.emplace_back(function_template_argument_);
			variables_.emplace_back(function_template_argument_typename_);
			variables_.emplace_back(function_type_);
			variables_.emplace_back(function_type_ls_);
			variables_.emplace_back(header_guard_);
			variables_.emplace_back(inherit_);
			variables_.emplace_back(invalidation_add_);
			variables_.emplace_back(invalidation_counter_);
			variables_.emplace_back(invalidation_remove_);
			variables_.emplace_back(is_invalidated_check_);
			variables_.emplace_back(language_name_);
			variables_.emplace_back(left_angle_bracket_);
			variables_.emplace_back(left_bracket_);
			variables_.emplace_back(left_curly_bracket_);
			variables_.emplace_back(miror_manipulation_);
			variables_.emplace_back(object_base_type_);
			variables_.emplace_back(object_type_);
			variables_.emplace_back(object_type_name_);
			variables_.emplace_back(optional_action_pop_);
			variables_.emplace_back(optional_action_push_);
			variables_.emplace_back(optional_dispatch_mechanic_);
			variables_.emplace_back(optional_flavor_action_stack_);
			variables_.emplace_back(optional_invalidation_add_);
			variables_.emplace_back(optional_invalidation_counter_);
			variables_.emplace_back(optional_invalidation_remove_);
			variables_.emplace_back(optional_is_invalidated_check_);
			variables_.emplace_back(optional_value_);
			variables_.emplace_back(output_name_);
			variables_.emplace_back(right_angle_bracket_);
			variables_.emplace_back(right_bracket_);
			variables_.emplace_back(right_curly_bracket_);
			variables_.emplace_back(sub_member_access_name_);
			variables_.emplace_back(target_namespace_);
			variables_.emplace_back(template_base_dispatch_function_);
			variables_.emplace_back(user_function_section_);
			variables_.emplace_back(user_include_section_);
			variables_.emplace_back(user_member_section_);
			variables_.emplace_back(value_);
			variables_.emplace_back(visit_function_name_);
		}

		virtual ~EntryExitListenerTemplate()
		{
			for (auto* variable : variables_to_delete)
			{
				delete variable;
			}

			variables_to_delete.clear();
		}

	public:
		// Default DST functions

		/*!	\fn GetOutput
		 *
		 *	\brief returns the output with the given the current state.
		 */
		std::string GetOutput()
		{
			return file_->Content()->GetValue();
		}

		/*!	\fn GetVariables
		 *
		 *	\brief Returns all top level variables known in this template.
		 */
		std::vector<VariableBase*> GetVariables()
		{
			return variables_;
		}

	public:
	};
}

#endif // FGL_IR_GENERATE_CPP_ENTRYEXITLISTENERTEMPLATE_h
