#ifndef FGL_FLAVORING_VISITOR_H
#define FGL_FLAVORING_VISITOR_H

/*      This is generated by FGL: https://github.com/Deruago/FGL
 *      For questions visit the link above!
 *
 *      Please do not edit this file, instead modify the definition that generated this!
 *
 *      You can use the class by the following:
 *  auto flavoring = ::fgl::flavoring::visitor::Flavoring();
 *      flavoring.Dispatch(tree);
 *
 *      If some setup is required, please use your inserted functions and members (if any),
 *      before using the flavoring class.
 *
 *      Note: This file requires C++17 or any later release.
 */

// User defined includes

#include "fgl/IR/Capture.h"
#include "fgl/IR/Fgl.h"
#include "fgl/IR/Instruction.h"
#include "fgl/IR/ManipulationRule.h"
#include "fgl/IR/Object.h"

// Required STL includes.
#include <stack>
#include <string>
#include <vector>

namespace fgl
{
	namespace flavoring
	{
		namespace visitor
		{
			/*!     \struct FlavorValue
			 *
			 *      \brief FlavorValue is used in flavors, when the flavor's value is accessed or
			 * modified.
			 *
			 *      \note If the flavor does not have references to its value, it will not be
			 * available in that flavor.
			 */
			struct FlavorValue
			{
				::std::vector<::std::vector<::std::string>> value;

				FlavorValue()
				{
					value.emplace_back();
				}

				~FlavorValue() = default;

				::std::vector<::std::string> GetValue() const
				{
					return *(value.end() - 1);
				}

				::std::vector<::std::string> operator()() const
				{
					return FlavorValue::GetValue();
				}

				void Reduce()
				{
					(value.end() - 1)->pop_back();
				}

				void Expand(const ::std::string& expandedValue)
				{
					(value.end() - 1)->push_back(expandedValue);
				}

				void Expand(const ::std::vector<::std::string>& expandedValues)
				{
					for (const auto& expandedValue : expandedValues)
					{
						(value.end() - 1)->push_back(expandedValue);
					}
				}

				FlavorValue& operator=(const ::std::string& newValue)
				{
					value.push_back({newValue});

					return *this;
				}

				FlavorValue& operator=(const ::std::vector<::std::string>& newValues)
				{
					value.push_back(newValues);

					return *this;
				}

				void RemoveValue()
				{
					value.pop_back();
				}
			};

			// Global flavor type forward declarations
			struct A;
			struct B;
			struct C;
			struct D;

			// Compile time known flavor specialization type forward declarations
			struct hallo;

			// Base flavor enumerations

			enum class FlavorType
			{
				// Reserved values
				FGL_RESERVED_Unknown = 0,

				// Default cases
				A,
				B,
				C,
				D,

				// Flavor specialization cases
				C_hallo,

			};

			// Specialization flavor enumerations
			enum class ASpecializationType
			{
				// Reserved values
				FGL_RESERVED_Unknown = 0,

			};
			enum class BSpecializationType
			{
				// Reserved values
				FGL_RESERVED_Unknown = 0,

			};
			enum class CSpecializationType
			{
				// Reserved values
				FGL_RESERVED_Unknown = 0,

				C_hallo,

			};
			enum class DSpecializationType
			{
				// Reserved values
				FGL_RESERVED_Unknown = 0,

			};

			// Flavor specialization enum to type conversion

			template<ASpecializationType type>
			struct AEnumToType
			{
				using type = void;
			};

			template<BSpecializationType type>
			struct BEnumToType
			{
				using type = void;
			};

			template<CSpecializationType type>
			struct CEnumToType
			{
				using type = void;
			};

			template<>
			struct CEnumToType<CSpecializationType::C_hallo>
			{
				using type = hallo;
			};

			template<DSpecializationType type>
			struct DEnumToType
			{
				using type = void;
			};

			/*!     \struct FlavorStackMemory
			 *
			 *      \brief This is used to keep track of when a flavor is added/deleted.
			 *
			 *      \details It contains an invalidation counter and flavortype variable.
			 *      These 2 are used to keep track of what flavor was added, and if it was deleted.
			 *      Deleted flavors are invalidated in the stack.
			 *
			 *      \note If stack access is not used, this will not be used.
			 *
			 *      \note If runtime flavor specialization is supported, every check becomes more
			 * expensive.
			 */
			struct FlavorStackMemory
			{
			public:
				FlavorType flavorType;

			public:
				unsigned int invalidation = 0;

			public:
				FlavorStackMemory(FlavorType flavorType_) : flavorType(flavorType_)
				{
				}

				~FlavorStackMemory() = default;

			public:
				void Invalidate()
				{
					FlavorStackMemory::invalidation += 1;
				}

				void Validate()
				{
					FlavorStackMemory::invalidation -= 1;
				}

				bool IsInvalidate()
				{
					return FlavorStackMemory::invalidation > 0;
				}
			};

			struct hallo
			{
			public:
				FlavorValue value;

				// Counters
				int count = 0;

			public:
				hallo() = default;
				~hallo() = default;

				hallo(const hallo&) = delete;
				hallo(hallo&&) noexcept = delete;

				hallo& operator=(const hallo&) = delete;
				hallo& operator=(hallo&&) noexcept = delete;

			public:
				void Add()
				{
					hallo::count += 1;
				}

				void Remove()
				{
					hallo::count -= 1;
				}
			};

			struct A
			{
			public:
				FlavorValue value;

				// Counters
				int count = 0;

			public:
				// Compile time known possible flavor specializations

				// Run-time possible flavor specializations

			public:
				A() = default;
				~A() = default;

				A(const A&) = delete;
				A(A&&) noexcept = delete;

				A& operator=(const A&) = delete;
				A& operator=(A&&) noexcept = delete;

			public:
				template<ASpecializationType type>
				typename AEnumToType<type>::type& Get()
				{
					return {};
				}

				template<ASpecializationType type>
				void Add()
				{
					A::count += 1;
					A::Get<type>().Add();
				}

				void Add()
				{
					A::count += 1;
				}

				template<ASpecializationType type>
				void Remove()
				{
					A::count -= 1;
					A::Get<type>().Remove();
				}

				void Remove()
				{
					A::count -= 1;
				}
			};

			struct B
			{
			public:
				FlavorValue value;

				// Counters
				int count = 0;

			public:
				// Compile time known possible flavor specializations

				// Run-time possible flavor specializations

			public:
				B() = default;
				~B() = default;

				B(const B&) = delete;
				B(B&&) noexcept = delete;

				B& operator=(const B&) = delete;
				B& operator=(B&&) noexcept = delete;

			public:
				template<BSpecializationType type>
				typename BEnumToType<type>::type& Get()
				{
					return {};
				}

				template<BSpecializationType type>
				void Add()
				{
					B::count += 1;
					B::Get<type>().Add();
				}

				void Add()
				{
					B::count += 1;
				}

				template<BSpecializationType type>
				void Remove()
				{
					B::count -= 1;
					B::Get<type>().Remove();
				}

				void Remove()
				{
					B::count -= 1;
				}
			};

			struct C
			{
			public:
				FlavorValue value;

				// Counters
				int count = 0;

			public:
				// Compile time known possible flavor specializations
				hallo hallo;

				// Run-time possible flavor specializations

			public:
				C() = default;
				~C() = default;

				C(const C&) = delete;
				C(C&&) noexcept = delete;

				C& operator=(const C&) = delete;
				C& operator=(C&&) noexcept = delete;

			public:
				template<CSpecializationType type>
				typename CEnumToType<type>::type& Get()
				{
					if constexpr (type == CSpecializationType::C_hallo)
					{
						return C::hallo;
					}

					return {};
				}

				template<CSpecializationType type>
				void Add()
				{
					C::count += 1;
					C::Get<type>().Add();
				}

				void Add()
				{
					C::count += 1;
				}

				template<CSpecializationType type>
				void Remove()
				{
					C::count -= 1;
					C::Get<type>().Remove();
				}

				void Remove()
				{
					C::count -= 1;
				}
			};

			struct D
			{
			public:
				FlavorValue value;

				// Counters
				int count = 0;

			public:
				// Compile time known possible flavor specializations

				// Run-time possible flavor specializations

			public:
				D() = default;
				~D() = default;

				D(const D&) = delete;
				D(D&&) noexcept = delete;

				D& operator=(const D&) = delete;
				D& operator=(D&&) noexcept = delete;

			public:
				template<DSpecializationType type>
				typename DEnumToType<type>::type& Get()
				{
					return {};
				}

				template<DSpecializationType type>
				void Add()
				{
					D::count += 1;
					D::Get<type>().Add();
				}

				void Add()
				{
					D::count += 1;
				}

				template<DSpecializationType type>
				void Remove()
				{
					D::count -= 1;
					D::Get<type>().Remove();
				}

				void Remove()
				{
					D::count -= 1;
				}
			};

			/*!     \class Flavoring
			 *
			 *      \brief Applies flavoring to Flavoring.
			 *
			 *      \details This flavoring is generated and optimized using a flavoring definition
			 * and FGL.
			 *
			 *      \note It is not recommended to edit this file to apply changes.
			 *      To apply changes please change the flavoring definition of this file.
			 *
			 */
			class Flavoring
			{
			private:
				A A;
				B B;
				C C;
				D D;

			private:
				::std::stack<::std::size_t> flavorActionStack;

			public:
				Flavoring() = default;
				~Flavoring() = default;

			private:
				// Entry of nodes
				void EntryCapture(::fgl::ir::Capture* node)
				{
					if (D.count > 0 && true)
					{
						A.Add();
						B.Add();
						C.Add<CSpecializationType::C_hallo>();

						flavorActionStack.push(0);

						return;
					}

					// Uncaptured part.
				}
				void EntryInstruction(::fgl::ir::Instruction* node)
				{
					if (C.Get<CSpecializationType::C_hallo>().count > 0 && true)
					{
						C.Add();
						C.value.Expand("a");

						flavorActionStack.push(0);

						return;
					}

					// Uncaptured part.
				}
				void EntryManipulationRule(::fgl::ir::ManipulationRule* node)
				{
					if (true)
					{
						A.Add();
						B.Add();
						D.Add();

						flavorActionStack.push(0);

						return;
					}

					// Uncaptured part.
				}
				void EntryObject(::fgl::ir::Object* node)
				{
					if (A.count > 0 && B.count > 0 && C.count > 0 && true)
					{
						A.Add();
						B.Add();
						C.Remove();

						flavorActionStack.push(0);

						return;
					}

					// Uncaptured part.
				}

				// Exit of nodes
				void ExitCapture(::fgl::ir::Capture* node)
				{
					if (0 == flavorActionStack.top())
					{
						A.Remove();
						B.Remove();
						C.Remove<CSpecializationType::C_hallo>();

						flavorActionStack.pop();

						return;
					}
				}
				void ExitInstruction(::fgl::ir::Instruction* node)
				{
					if (0 == flavorActionStack.top())
					{
						C.Remove();
						C.value.Reduce();

						flavorActionStack.pop();

						return;
					}
				}
				void ExitManipulationRule(::fgl::ir::ManipulationRule* node)
				{
					if (0 == flavorActionStack.top())
					{
						A.Remove();
						B.Remove();
						D.Remove();

						flavorActionStack.pop();

						return;
					}
				}
				void ExitObject(::fgl::ir::Object* node)
				{
					if (0 == flavorActionStack.top())
					{
						A.Remove();
						B.Remove();
						C.Add();

						flavorActionStack.pop();

						return;
					}
				}

			private:
				// Dispatch function

				template<typename T>
				void Dispatch(T* node)
				{
					for (auto* subNode : node->GetNodes())
					{
						subNode->Accept(this);
					}
				}

				// Subtype dispatch functions

				void Dispatch(::fgl::ir::Capture* node)
				{
					EntryCapture(node);

					for (auto* subNode : node->GetNodes())
					{
						subNode->Accept(this);
					}

					ExitCapture(node);
				}

				void Dispatch(::fgl::ir::Instruction* node)
				{
					EntryInstruction(node);

					for (auto* subNode : node->GetNodes())
					{
						subNode->Accept(this);
					}

					ExitInstruction(node);
				}

				void Dispatch(::fgl::ir::ManipulationRule* node)
				{
					EntryManipulationRule(node);

					for (auto* subNode : node->GetNodes())
					{
						subNode->Accept(this);
					}

					ExitManipulationRule(node);
				}

				void Dispatch(::fgl::ir::Object* node)
				{
					EntryObject(node);

					for (auto* subNode : node->GetNodes())
					{
						subNode->Accept(this);
					}

					ExitObject(node);
				}

				// User defined members
			public:
				ir::Fgl fgl;
				std::vector<ir::ManipulationRule> manipulationRules;
				std::vector<ir::Capture> captures;
				std::vector<ir::Instruction> instructions;
				std::optional<ir::Object> object;

				// User defined functions
			public:
				ir::Fgl output()
				{
					return fgl;
				}
			};

		}
	}
}

#endif // FGL_FLAVORING_VISITOR_H
